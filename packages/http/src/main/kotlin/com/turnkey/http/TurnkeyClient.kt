// @generated by codegen. DO NOT EDIT BY HAND
@file:Suppress(
  "unused",
  "UNUSED_PARAMETER",
  "UNUSED_VARIABLE",
  "RedundantVisibilityModifier",
  "MemberVisibilityCanBePrivate",
  "RedundantSuspendModifier",
)

package com.turnkey.http

import com.turnkey.http.utils.ActivityPollerConfig
import com.turnkey.http.utils.TurnkeyHttpError
import com.turnkey.stamper.Stamper
import com.turnkey.types.ProxyTGetAccountBody
import com.turnkey.types.ProxyTGetAccountResponse
import com.turnkey.types.ProxyTGetWalletKitConfigBody
import com.turnkey.types.ProxyTGetWalletKitConfigResponse
import com.turnkey.types.ProxyTInitOtpBody
import com.turnkey.types.ProxyTInitOtpResponse
import com.turnkey.types.ProxyTOAuth2AuthenticateBody
import com.turnkey.types.ProxyTOAuth2AuthenticateResponse
import com.turnkey.types.ProxyTOAuthLoginBody
import com.turnkey.types.ProxyTOAuthLoginResponse
import com.turnkey.types.ProxyTOtpLoginBody
import com.turnkey.types.ProxyTOtpLoginResponse
import com.turnkey.types.ProxyTSignupBody
import com.turnkey.types.ProxyTSignupResponse
import com.turnkey.types.ProxyTVerifyOtpBody
import com.turnkey.types.ProxyTVerifyOtpResponse
import com.turnkey.types.TApproveActivityBody
import com.turnkey.types.TApproveActivityResponse
import com.turnkey.types.TApproveTvcDeploymentBody
import com.turnkey.types.TApproveTvcDeploymentResponse
import com.turnkey.types.TCreateApiKeysBody
import com.turnkey.types.TCreateApiKeysResponse
import com.turnkey.types.TCreateApiOnlyUsersBody
import com.turnkey.types.TCreateApiOnlyUsersResponse
import com.turnkey.types.TCreateAuthenticatorsBody
import com.turnkey.types.TCreateAuthenticatorsResponse
import com.turnkey.types.TCreateFiatOnRampCredentialBody
import com.turnkey.types.TCreateFiatOnRampCredentialResponse
import com.turnkey.types.TCreateInvitationsBody
import com.turnkey.types.TCreateInvitationsResponse
import com.turnkey.types.TCreateOauth2CredentialBody
import com.turnkey.types.TCreateOauth2CredentialResponse
import com.turnkey.types.TCreateOauthProvidersBody
import com.turnkey.types.TCreateOauthProvidersResponse
import com.turnkey.types.TCreatePoliciesBody
import com.turnkey.types.TCreatePoliciesResponse
import com.turnkey.types.TCreatePolicyBody
import com.turnkey.types.TCreatePolicyResponse
import com.turnkey.types.TCreatePrivateKeyTagBody
import com.turnkey.types.TCreatePrivateKeyTagResponse
import com.turnkey.types.TCreatePrivateKeysBody
import com.turnkey.types.TCreatePrivateKeysResponse
import com.turnkey.types.TCreateReadOnlySessionBody
import com.turnkey.types.TCreateReadOnlySessionResponse
import com.turnkey.types.TCreateReadWriteSessionBody
import com.turnkey.types.TCreateReadWriteSessionResponse
import com.turnkey.types.TCreateSmartContractInterfaceBody
import com.turnkey.types.TCreateSmartContractInterfaceResponse
import com.turnkey.types.TCreateSubOrganizationBody
import com.turnkey.types.TCreateSubOrganizationResponse
import com.turnkey.types.TCreateTvcAppBody
import com.turnkey.types.TCreateTvcAppResponse
import com.turnkey.types.TCreateTvcDeploymentBody
import com.turnkey.types.TCreateTvcDeploymentResponse
import com.turnkey.types.TCreateUserTagBody
import com.turnkey.types.TCreateUserTagResponse
import com.turnkey.types.TCreateUsersBody
import com.turnkey.types.TCreateUsersResponse
import com.turnkey.types.TCreateWalletAccountsBody
import com.turnkey.types.TCreateWalletAccountsResponse
import com.turnkey.types.TCreateWalletBody
import com.turnkey.types.TCreateWalletResponse
import com.turnkey.types.TDeleteApiKeysBody
import com.turnkey.types.TDeleteApiKeysResponse
import com.turnkey.types.TDeleteAuthenticatorsBody
import com.turnkey.types.TDeleteAuthenticatorsResponse
import com.turnkey.types.TDeleteFiatOnRampCredentialBody
import com.turnkey.types.TDeleteFiatOnRampCredentialResponse
import com.turnkey.types.TDeleteInvitationBody
import com.turnkey.types.TDeleteInvitationResponse
import com.turnkey.types.TDeleteOauth2CredentialBody
import com.turnkey.types.TDeleteOauth2CredentialResponse
import com.turnkey.types.TDeleteOauthProvidersBody
import com.turnkey.types.TDeleteOauthProvidersResponse
import com.turnkey.types.TDeletePoliciesBody
import com.turnkey.types.TDeletePoliciesResponse
import com.turnkey.types.TDeletePolicyBody
import com.turnkey.types.TDeletePolicyResponse
import com.turnkey.types.TDeletePrivateKeyTagsBody
import com.turnkey.types.TDeletePrivateKeyTagsResponse
import com.turnkey.types.TDeletePrivateKeysBody
import com.turnkey.types.TDeletePrivateKeysResponse
import com.turnkey.types.TDeleteSmartContractInterfaceBody
import com.turnkey.types.TDeleteSmartContractInterfaceResponse
import com.turnkey.types.TDeleteSubOrganizationBody
import com.turnkey.types.TDeleteSubOrganizationResponse
import com.turnkey.types.TDeleteUserTagsBody
import com.turnkey.types.TDeleteUserTagsResponse
import com.turnkey.types.TDeleteUsersBody
import com.turnkey.types.TDeleteUsersResponse
import com.turnkey.types.TDeleteWalletAccountsBody
import com.turnkey.types.TDeleteWalletAccountsResponse
import com.turnkey.types.TDeleteWalletsBody
import com.turnkey.types.TDeleteWalletsResponse
import com.turnkey.types.TEmailAuthBody
import com.turnkey.types.TEmailAuthResponse
import com.turnkey.types.TEthSendRawTransactionBody
import com.turnkey.types.TEthSendRawTransactionResponse
import com.turnkey.types.TEthSendTransactionBody
import com.turnkey.types.TEthSendTransactionResponse
import com.turnkey.types.TExportPrivateKeyBody
import com.turnkey.types.TExportPrivateKeyResponse
import com.turnkey.types.TExportWalletAccountBody
import com.turnkey.types.TExportWalletAccountResponse
import com.turnkey.types.TExportWalletBody
import com.turnkey.types.TExportWalletResponse
import com.turnkey.types.TGetActivitiesBody
import com.turnkey.types.TGetActivitiesResponse
import com.turnkey.types.TGetActivityBody
import com.turnkey.types.TGetActivityResponse
import com.turnkey.types.TGetApiKeyBody
import com.turnkey.types.TGetApiKeyResponse
import com.turnkey.types.TGetApiKeysBody
import com.turnkey.types.TGetApiKeysResponse
import com.turnkey.types.TGetAppProofsBody
import com.turnkey.types.TGetAppProofsResponse
import com.turnkey.types.TGetAttestationDocumentBody
import com.turnkey.types.TGetAttestationDocumentResponse
import com.turnkey.types.TGetAuthenticatorBody
import com.turnkey.types.TGetAuthenticatorResponse
import com.turnkey.types.TGetAuthenticatorsBody
import com.turnkey.types.TGetAuthenticatorsResponse
import com.turnkey.types.TGetBootProofBody
import com.turnkey.types.TGetBootProofResponse
import com.turnkey.types.TGetGasUsageBody
import com.turnkey.types.TGetGasUsageResponse
import com.turnkey.types.TGetLatestBootProofBody
import com.turnkey.types.TGetLatestBootProofResponse
import com.turnkey.types.TGetNoncesBody
import com.turnkey.types.TGetNoncesResponse
import com.turnkey.types.TGetOauth2CredentialBody
import com.turnkey.types.TGetOauth2CredentialResponse
import com.turnkey.types.TGetOauthProvidersBody
import com.turnkey.types.TGetOauthProvidersResponse
import com.turnkey.types.TGetOnRampTransactionStatusBody
import com.turnkey.types.TGetOnRampTransactionStatusResponse
import com.turnkey.types.TGetOrganizationBody
import com.turnkey.types.TGetOrganizationConfigsBody
import com.turnkey.types.TGetOrganizationConfigsResponse
import com.turnkey.types.TGetOrganizationResponse
import com.turnkey.types.TGetPoliciesBody
import com.turnkey.types.TGetPoliciesResponse
import com.turnkey.types.TGetPolicyBody
import com.turnkey.types.TGetPolicyEvaluationsBody
import com.turnkey.types.TGetPolicyEvaluationsResponse
import com.turnkey.types.TGetPolicyResponse
import com.turnkey.types.TGetPrivateKeyBody
import com.turnkey.types.TGetPrivateKeyResponse
import com.turnkey.types.TGetPrivateKeysBody
import com.turnkey.types.TGetPrivateKeysResponse
import com.turnkey.types.TGetSendTransactionStatusBody
import com.turnkey.types.TGetSendTransactionStatusResponse
import com.turnkey.types.TGetSmartContractInterfaceBody
import com.turnkey.types.TGetSmartContractInterfaceResponse
import com.turnkey.types.TGetSmartContractInterfacesBody
import com.turnkey.types.TGetSmartContractInterfacesResponse
import com.turnkey.types.TGetSubOrgIdsBody
import com.turnkey.types.TGetSubOrgIdsResponse
import com.turnkey.types.TGetTvcAppBody
import com.turnkey.types.TGetTvcAppResponse
import com.turnkey.types.TGetTvcAppsBody
import com.turnkey.types.TGetTvcAppsResponse
import com.turnkey.types.TGetUserBody
import com.turnkey.types.TGetUserResponse
import com.turnkey.types.TGetUsersBody
import com.turnkey.types.TGetUsersResponse
import com.turnkey.types.TGetVerifiedSubOrgIdsBody
import com.turnkey.types.TGetVerifiedSubOrgIdsResponse
import com.turnkey.types.TGetWalletAccountBody
import com.turnkey.types.TGetWalletAccountResponse
import com.turnkey.types.TGetWalletAccountsBody
import com.turnkey.types.TGetWalletAccountsResponse
import com.turnkey.types.TGetWalletBody
import com.turnkey.types.TGetWalletResponse
import com.turnkey.types.TGetWalletsBody
import com.turnkey.types.TGetWalletsResponse
import com.turnkey.types.TGetWhoamiBody
import com.turnkey.types.TGetWhoamiResponse
import com.turnkey.types.TImportPrivateKeyBody
import com.turnkey.types.TImportPrivateKeyResponse
import com.turnkey.types.TImportWalletBody
import com.turnkey.types.TImportWalletResponse
import com.turnkey.types.TInitFiatOnRampBody
import com.turnkey.types.TInitFiatOnRampResponse
import com.turnkey.types.TInitImportPrivateKeyBody
import com.turnkey.types.TInitImportPrivateKeyResponse
import com.turnkey.types.TInitImportWalletBody
import com.turnkey.types.TInitImportWalletResponse
import com.turnkey.types.TInitOtpAuthBody
import com.turnkey.types.TInitOtpAuthResponse
import com.turnkey.types.TInitOtpBody
import com.turnkey.types.TInitOtpResponse
import com.turnkey.types.TInitUserEmailRecoveryBody
import com.turnkey.types.TInitUserEmailRecoveryResponse
import com.turnkey.types.TListFiatOnRampCredentialsBody
import com.turnkey.types.TListFiatOnRampCredentialsResponse
import com.turnkey.types.TListOauth2CredentialsBody
import com.turnkey.types.TListOauth2CredentialsResponse
import com.turnkey.types.TListPrivateKeyTagsBody
import com.turnkey.types.TListPrivateKeyTagsResponse
import com.turnkey.types.TListUserTagsBody
import com.turnkey.types.TListUserTagsResponse
import com.turnkey.types.TNOOPCodegenAnchorResponse
import com.turnkey.types.TOauth2AuthenticateBody
import com.turnkey.types.TOauth2AuthenticateResponse
import com.turnkey.types.TOauthBody
import com.turnkey.types.TOauthLoginBody
import com.turnkey.types.TOauthLoginResponse
import com.turnkey.types.TOauthResponse
import com.turnkey.types.TOtpAuthBody
import com.turnkey.types.TOtpAuthResponse
import com.turnkey.types.TOtpLoginBody
import com.turnkey.types.TOtpLoginResponse
import com.turnkey.types.TRecoverUserBody
import com.turnkey.types.TRecoverUserResponse
import com.turnkey.types.TRefreshFeatureFlagsBody
import com.turnkey.types.TRefreshFeatureFlagsResponse
import com.turnkey.types.TRejectActivityBody
import com.turnkey.types.TRejectActivityResponse
import com.turnkey.types.TRemoveOrganizationFeatureBody
import com.turnkey.types.TRemoveOrganizationFeatureResponse
import com.turnkey.types.TSetOrganizationFeatureBody
import com.turnkey.types.TSetOrganizationFeatureResponse
import com.turnkey.types.TSignRawPayloadBody
import com.turnkey.types.TSignRawPayloadResponse
import com.turnkey.types.TSignRawPayloadsBody
import com.turnkey.types.TSignRawPayloadsResponse
import com.turnkey.types.TSignTransactionBody
import com.turnkey.types.TSignTransactionResponse
import com.turnkey.types.TSignedRequest
import com.turnkey.types.TStamp
import com.turnkey.types.TStampLoginBody
import com.turnkey.types.TStampLoginResponse
import com.turnkey.types.TTestRateLimitsBody
import com.turnkey.types.TTestRateLimitsResponse
import com.turnkey.types.TUpdateFiatOnRampCredentialBody
import com.turnkey.types.TUpdateFiatOnRampCredentialResponse
import com.turnkey.types.TUpdateOauth2CredentialBody
import com.turnkey.types.TUpdateOauth2CredentialResponse
import com.turnkey.types.TUpdatePolicyBody
import com.turnkey.types.TUpdatePolicyResponse
import com.turnkey.types.TUpdatePrivateKeyTagBody
import com.turnkey.types.TUpdatePrivateKeyTagResponse
import com.turnkey.types.TUpdateRootQuorumBody
import com.turnkey.types.TUpdateRootQuorumResponse
import com.turnkey.types.TUpdateUserBody
import com.turnkey.types.TUpdateUserEmailBody
import com.turnkey.types.TUpdateUserEmailResponse
import com.turnkey.types.TUpdateUserNameBody
import com.turnkey.types.TUpdateUserNameResponse
import com.turnkey.types.TUpdateUserPhoneNumberBody
import com.turnkey.types.TUpdateUserPhoneNumberResponse
import com.turnkey.types.TUpdateUserResponse
import com.turnkey.types.TUpdateUserTagBody
import com.turnkey.types.TUpdateUserTagResponse
import com.turnkey.types.TUpdateWalletBody
import com.turnkey.types.TUpdateWalletResponse
import com.turnkey.types.TVerifyOtpBody
import com.turnkey.types.TVerifyOtpResponse
import com.turnkey.types.V1Activity
import com.turnkey.types.V1ActivityResponse
import com.turnkey.types.V1ActivityStatus
import java.io.IOException
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.Suppress
import kotlin.collections.Set
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlinx.coroutines.withContext
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.jsonObject
import kotlinx.serialization.json.jsonPrimitive
import okhttp3.Call
import okhttp3.Callback
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import okhttp3.Response

/**
 * HTTP Client for interacting with Turnkey API (generated). DO NOT EDIT BY HAND.
 */
public class TurnkeyClient(
  apiBaseUrl: String? = null,
  private val stamper: Stamper?,
  http: OkHttpClient? = null,
  authProxyUrl: String? = null,
  private val authProxyConfigId: String? = null,
  private val organizationId: String,
  private val activityPoller: ActivityPollerConfig? = null,
) {
  private val apiBaseUrl: String = apiBaseUrl ?: "https://api.turnkey.com"

  private val http: OkHttpClient = http ?: OkHttpClient()

  private val authProxyUrl: String = authProxyUrl ?: "https://authproxy.turnkey.com"

  private val json: Json = Json { ignoreUnknownKeys = true }

  private suspend fun Call.await(): Response = suspendCancellableCoroutine { cont ->
      this@await.enqueue(object : Callback {
          override fun onFailure(call: Call, e: IOException) {
              if (!cont.isCompleted) cont.resumeWithException(e)
          }
          override fun onResponse(call: Call, response: Response) {
              if (!cont.isCompleted) cont.resume(response)
          }
      })
      cont.invokeOnCancellation { kotlin.runCatching { cancel() }.getOrNull() }
  }

  private suspend fun pollActivityStatus(
    activityId: String,
    intervalMs: Long,
    maxRetries: Int,
  ): V1Activity {
    var attempts = 0

    while (attempts <= maxRetries) {
        delay(intervalMs)

        val pollBody = TGetActivityBody(activityId = activityId)
        val pollResponse = getActivity(pollBody)
        val activity = pollResponse.activity

        if (activity.status in TERMINAL_ACTIVITY_STATUSES) {
            return activity
        }

        attempts++
    }

    // Return the last polled activity even if max retries exceeded
    val finalPollBody = TGetActivityBody(activityId = activityId)
    return getActivity(finalPollBody).activity
  }

  private suspend inline fun <reified TBodyType> activity(
    url: String,
    body: TBodyType,
    activityType: String,
  ): V1Activity {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()

    val inputJson = json.encodeToJsonElement(kotlinx.serialization.serializer<TBodyType>(), body)
    val obj = inputJson.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]

    val params = kotlinx.serialization.json.buildJsonObject {
        obj.forEach { (k, v) ->
            if (k != "organizationId" && k != "timestampMs") put(k, v)
        }
    }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()

    // Use provided organizationId from body, or fall back to client's organizationId
    val finalOrgId = inputOrgId ?: kotlinx.serialization.json.JsonPrimitive(organizationId)

    val bodyObj = kotlinx.serialization.json.buildJsonObject {
        put("parameters", params)
        finalOrgId?.let { put("organizationId", it) }
        put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts))
        put("type", kotlinx.serialization.json.JsonPrimitive(activityType))
    }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)

    val req = Request.Builder()
        .url(url)
        .post(bodyJson.toRequestBody("application/json".toMediaType()))
        .header(hName, hValue)
        .header("X-Client-Version", Version.VERSION)
        .build()

    val resp = http.newCall(req).await()

    val initialActivity = resp.use {
        if (!it.isSuccessful) {
            val errBody = withContext(Dispatchers.IO) {
                kotlin.runCatching { it.body.string() }.getOrNull()
            }
            throw RuntimeException("HTTP error calling $activityType request\nError: $errBody\nCode: ${it.code}")
        }
        val text = withContext(Dispatchers.IO) { it.body.string() }
        json.decodeFromString<V1ActivityResponse>(text).activity
    }

    // Check if polling is enabled and needed
    if (activityPoller != null && initialActivity.status !in TERMINAL_ACTIVITY_STATUSES) {
        return pollActivityStatus(initialActivity.id, activityPoller.intervalMs, activityPoller.numRetries)
    }

    return initialActivity
  }

  public suspend fun getActivity(input: TGetActivityBody): TGetActivityResponse {
    val url = "$apiBaseUrl/public/v1/query/get_activity"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetActivityBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/get_activity: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetActivityResponse.serializer(), text)
    }
  }

  public suspend fun stampGetActivity(input: TGetActivityBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/get_activity"
    val bodyJson = json.encodeToJsonElement(TGetActivityBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getApiKey(input: TGetApiKeyBody): TGetApiKeyResponse {
    val url = "$apiBaseUrl/public/v1/query/get_api_key"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetApiKeyBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/get_api_key: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetApiKeyResponse.serializer(), text)
    }
  }

  public suspend fun stampGetApiKey(input: TGetApiKeyBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/get_api_key"
    val bodyJson = json.encodeToJsonElement(TGetApiKeyBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getApiKeys(input: TGetApiKeysBody): TGetApiKeysResponse {
    val url = "$apiBaseUrl/public/v1/query/get_api_keys"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetApiKeysBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/get_api_keys: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetApiKeysResponse.serializer(), text)
    }
  }

  public suspend fun stampGetApiKeys(input: TGetApiKeysBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/get_api_keys"
    val bodyJson = json.encodeToJsonElement(TGetApiKeysBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getAttestationDocument(input: TGetAttestationDocumentBody): TGetAttestationDocumentResponse {
    val url = "$apiBaseUrl/public/v1/query/get_attestation"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetAttestationDocumentBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/get_attestation: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetAttestationDocumentResponse.serializer(), text)
    }
  }

  public suspend fun stampGetAttestationDocument(input: TGetAttestationDocumentBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/get_attestation"
    val bodyJson = json.encodeToJsonElement(TGetAttestationDocumentBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getAuthenticator(input: TGetAuthenticatorBody): TGetAuthenticatorResponse {
    val url = "$apiBaseUrl/public/v1/query/get_authenticator"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetAuthenticatorBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/get_authenticator: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetAuthenticatorResponse.serializer(), text)
    }
  }

  public suspend fun stampGetAuthenticator(input: TGetAuthenticatorBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/get_authenticator"
    val bodyJson = json.encodeToJsonElement(TGetAuthenticatorBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getAuthenticators(input: TGetAuthenticatorsBody): TGetAuthenticatorsResponse {
    val url = "$apiBaseUrl/public/v1/query/get_authenticators"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetAuthenticatorsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/get_authenticators: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetAuthenticatorsResponse.serializer(), text)
    }
  }

  public suspend fun stampGetAuthenticators(input: TGetAuthenticatorsBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/get_authenticators"
    val bodyJson = json.encodeToJsonElement(TGetAuthenticatorsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getBootProof(input: TGetBootProofBody): TGetBootProofResponse {
    val url = "$apiBaseUrl/public/v1/query/get_boot_proof"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetBootProofBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/get_boot_proof: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetBootProofResponse.serializer(), text)
    }
  }

  public suspend fun stampGetBootProof(input: TGetBootProofBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/get_boot_proof"
    val bodyJson = json.encodeToJsonElement(TGetBootProofBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getGasUsage(input: TGetGasUsageBody): TGetGasUsageResponse {
    val url = "$apiBaseUrl/public/v1/query/get_gas_usage"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetGasUsageBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/get_gas_usage: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetGasUsageResponse.serializer(), text)
    }
  }

  public suspend fun stampGetGasUsage(input: TGetGasUsageBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/get_gas_usage"
    val bodyJson = json.encodeToJsonElement(TGetGasUsageBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getLatestBootProof(input: TGetLatestBootProofBody): TGetLatestBootProofResponse {
    val url = "$apiBaseUrl/public/v1/query/get_latest_boot_proof"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetLatestBootProofBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/get_latest_boot_proof: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetLatestBootProofResponse.serializer(), text)
    }
  }

  public suspend fun stampGetLatestBootProof(input: TGetLatestBootProofBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/get_latest_boot_proof"
    val bodyJson = json.encodeToJsonElement(TGetLatestBootProofBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getNonces(input: TGetNoncesBody): TGetNoncesResponse {
    val url = "$apiBaseUrl/public/v1/query/get_nonces"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetNoncesBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/get_nonces: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetNoncesResponse.serializer(), text)
    }
  }

  public suspend fun stampGetNonces(input: TGetNoncesBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/get_nonces"
    val bodyJson = json.encodeToJsonElement(TGetNoncesBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getOauth2Credential(input: TGetOauth2CredentialBody): TGetOauth2CredentialResponse {
    val url = "$apiBaseUrl/public/v1/query/get_oauth2_credential"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetOauth2CredentialBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/get_oauth2_credential: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetOauth2CredentialResponse.serializer(), text)
    }
  }

  public suspend fun stampGetOauth2Credential(input: TGetOauth2CredentialBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/get_oauth2_credential"
    val bodyJson = json.encodeToJsonElement(TGetOauth2CredentialBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getOauthProviders(input: TGetOauthProvidersBody): TGetOauthProvidersResponse {
    val url = "$apiBaseUrl/public/v1/query/get_oauth_providers"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetOauthProvidersBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/get_oauth_providers: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetOauthProvidersResponse.serializer(), text)
    }
  }

  public suspend fun stampGetOauthProviders(input: TGetOauthProvidersBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/get_oauth_providers"
    val bodyJson = json.encodeToJsonElement(TGetOauthProvidersBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getOnRampTransactionStatus(input: TGetOnRampTransactionStatusBody): TGetOnRampTransactionStatusResponse {
    val url = "$apiBaseUrl/public/v1/query/get_onramp_transaction_status"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetOnRampTransactionStatusBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/get_onramp_transaction_status: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetOnRampTransactionStatusResponse.serializer(), text)
    }
  }

  public suspend fun stampGetOnRampTransactionStatus(input: TGetOnRampTransactionStatusBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/get_onramp_transaction_status"
    val bodyJson = json.encodeToJsonElement(TGetOnRampTransactionStatusBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getOrganization(input: TGetOrganizationBody): TGetOrganizationResponse {
    val url = "$apiBaseUrl/public/v1/query/get_organization"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetOrganizationBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/get_organization: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetOrganizationResponse.serializer(), text)
    }
  }

  public suspend fun stampGetOrganization(input: TGetOrganizationBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/get_organization"
    val bodyJson = json.encodeToJsonElement(TGetOrganizationBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getOrganizationConfigs(input: TGetOrganizationConfigsBody): TGetOrganizationConfigsResponse {
    val url = "$apiBaseUrl/public/v1/query/get_organization_configs"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetOrganizationConfigsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/get_organization_configs: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetOrganizationConfigsResponse.serializer(), text)
    }
  }

  public suspend fun stampGetOrganizationConfigs(input: TGetOrganizationConfigsBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/get_organization_configs"
    val bodyJson = json.encodeToJsonElement(TGetOrganizationConfigsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getPolicy(input: TGetPolicyBody): TGetPolicyResponse {
    val url = "$apiBaseUrl/public/v1/query/get_policy"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetPolicyBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/get_policy: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetPolicyResponse.serializer(), text)
    }
  }

  public suspend fun stampGetPolicy(input: TGetPolicyBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/get_policy"
    val bodyJson = json.encodeToJsonElement(TGetPolicyBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getPolicyEvaluations(input: TGetPolicyEvaluationsBody): TGetPolicyEvaluationsResponse {
    val url = "$apiBaseUrl/public/v1/query/get_policy_evaluations"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetPolicyEvaluationsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/get_policy_evaluations: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetPolicyEvaluationsResponse.serializer(), text)
    }
  }

  public suspend fun stampGetPolicyEvaluations(input: TGetPolicyEvaluationsBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/get_policy_evaluations"
    val bodyJson = json.encodeToJsonElement(TGetPolicyEvaluationsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getPrivateKey(input: TGetPrivateKeyBody): TGetPrivateKeyResponse {
    val url = "$apiBaseUrl/public/v1/query/get_private_key"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetPrivateKeyBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/get_private_key: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetPrivateKeyResponse.serializer(), text)
    }
  }

  public suspend fun stampGetPrivateKey(input: TGetPrivateKeyBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/get_private_key"
    val bodyJson = json.encodeToJsonElement(TGetPrivateKeyBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getSendTransactionStatus(input: TGetSendTransactionStatusBody): TGetSendTransactionStatusResponse {
    val url = "$apiBaseUrl/public/v1/query/get_send_transaction_status"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetSendTransactionStatusBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/get_send_transaction_status: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetSendTransactionStatusResponse.serializer(), text)
    }
  }

  public suspend fun stampGetSendTransactionStatus(input: TGetSendTransactionStatusBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/get_send_transaction_status"
    val bodyJson = json.encodeToJsonElement(TGetSendTransactionStatusBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getSmartContractInterface(input: TGetSmartContractInterfaceBody): TGetSmartContractInterfaceResponse {
    val url = "$apiBaseUrl/public/v1/query/get_smart_contract_interface"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetSmartContractInterfaceBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/get_smart_contract_interface: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetSmartContractInterfaceResponse.serializer(), text)
    }
  }

  public suspend fun stampGetSmartContractInterface(input: TGetSmartContractInterfaceBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/get_smart_contract_interface"
    val bodyJson = json.encodeToJsonElement(TGetSmartContractInterfaceBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getTvcApp(input: TGetTvcAppBody): TGetTvcAppResponse {
    val url = "$apiBaseUrl/public/v1/query/get_tvc_app"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetTvcAppBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/get_tvc_app: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetTvcAppResponse.serializer(), text)
    }
  }

  public suspend fun stampGetTvcApp(input: TGetTvcAppBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/get_tvc_app"
    val bodyJson = json.encodeToJsonElement(TGetTvcAppBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getUser(input: TGetUserBody): TGetUserResponse {
    val url = "$apiBaseUrl/public/v1/query/get_user"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetUserBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/get_user: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetUserResponse.serializer(), text)
    }
  }

  public suspend fun stampGetUser(input: TGetUserBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/get_user"
    val bodyJson = json.encodeToJsonElement(TGetUserBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getWallet(input: TGetWalletBody): TGetWalletResponse {
    val url = "$apiBaseUrl/public/v1/query/get_wallet"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetWalletBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/get_wallet: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetWalletResponse.serializer(), text)
    }
  }

  public suspend fun stampGetWallet(input: TGetWalletBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/get_wallet"
    val bodyJson = json.encodeToJsonElement(TGetWalletBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getWalletAccount(input: TGetWalletAccountBody): TGetWalletAccountResponse {
    val url = "$apiBaseUrl/public/v1/query/get_wallet_account"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetWalletAccountBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/get_wallet_account: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetWalletAccountResponse.serializer(), text)
    }
  }

  public suspend fun stampGetWalletAccount(input: TGetWalletAccountBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/get_wallet_account"
    val bodyJson = json.encodeToJsonElement(TGetWalletAccountBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getActivities(input: TGetActivitiesBody): TGetActivitiesResponse {
    val url = "$apiBaseUrl/public/v1/query/list_activities"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetActivitiesBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/list_activities: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetActivitiesResponse.serializer(), text)
    }
  }

  public suspend fun stampGetActivities(input: TGetActivitiesBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/list_activities"
    val bodyJson = json.encodeToJsonElement(TGetActivitiesBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getAppProofs(input: TGetAppProofsBody): TGetAppProofsResponse {
    val url = "$apiBaseUrl/public/v1/query/list_app_proofs"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetAppProofsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/list_app_proofs: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetAppProofsResponse.serializer(), text)
    }
  }

  public suspend fun stampGetAppProofs(input: TGetAppProofsBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/list_app_proofs"
    val bodyJson = json.encodeToJsonElement(TGetAppProofsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun listFiatOnRampCredentials(input: TListFiatOnRampCredentialsBody): TListFiatOnRampCredentialsResponse {
    val url = "$apiBaseUrl/public/v1/query/list_fiat_on_ramp_credentials"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TListFiatOnRampCredentialsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/list_fiat_on_ramp_credentials: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TListFiatOnRampCredentialsResponse.serializer(), text)
    }
  }

  public suspend fun stampListFiatOnRampCredentials(input: TListFiatOnRampCredentialsBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/list_fiat_on_ramp_credentials"
    val bodyJson = json.encodeToJsonElement(TListFiatOnRampCredentialsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun listOauth2Credentials(input: TListOauth2CredentialsBody): TListOauth2CredentialsResponse {
    val url = "$apiBaseUrl/public/v1/query/list_oauth2_credentials"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TListOauth2CredentialsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/list_oauth2_credentials: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TListOauth2CredentialsResponse.serializer(), text)
    }
  }

  public suspend fun stampListOauth2Credentials(input: TListOauth2CredentialsBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/list_oauth2_credentials"
    val bodyJson = json.encodeToJsonElement(TListOauth2CredentialsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getPolicies(input: TGetPoliciesBody): TGetPoliciesResponse {
    val url = "$apiBaseUrl/public/v1/query/list_policies"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetPoliciesBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/list_policies: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetPoliciesResponse.serializer(), text)
    }
  }

  public suspend fun stampGetPolicies(input: TGetPoliciesBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/list_policies"
    val bodyJson = json.encodeToJsonElement(TGetPoliciesBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun listPrivateKeyTags(input: TListPrivateKeyTagsBody): TListPrivateKeyTagsResponse {
    val url = "$apiBaseUrl/public/v1/query/list_private_key_tags"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TListPrivateKeyTagsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/list_private_key_tags: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TListPrivateKeyTagsResponse.serializer(), text)
    }
  }

  public suspend fun stampListPrivateKeyTags(input: TListPrivateKeyTagsBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/list_private_key_tags"
    val bodyJson = json.encodeToJsonElement(TListPrivateKeyTagsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getPrivateKeys(input: TGetPrivateKeysBody): TGetPrivateKeysResponse {
    val url = "$apiBaseUrl/public/v1/query/list_private_keys"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetPrivateKeysBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/list_private_keys: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetPrivateKeysResponse.serializer(), text)
    }
  }

  public suspend fun stampGetPrivateKeys(input: TGetPrivateKeysBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/list_private_keys"
    val bodyJson = json.encodeToJsonElement(TGetPrivateKeysBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getSmartContractInterfaces(input: TGetSmartContractInterfacesBody): TGetSmartContractInterfacesResponse {
    val url = "$apiBaseUrl/public/v1/query/list_smart_contract_interfaces"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetSmartContractInterfacesBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/list_smart_contract_interfaces: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetSmartContractInterfacesResponse.serializer(), text)
    }
  }

  public suspend fun stampGetSmartContractInterfaces(input: TGetSmartContractInterfacesBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/list_smart_contract_interfaces"
    val bodyJson = json.encodeToJsonElement(TGetSmartContractInterfacesBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getSubOrgIds(input: TGetSubOrgIdsBody): TGetSubOrgIdsResponse {
    val url = "$apiBaseUrl/public/v1/query/list_suborgs"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetSubOrgIdsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/list_suborgs: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetSubOrgIdsResponse.serializer(), text)
    }
  }

  public suspend fun stampGetSubOrgIds(input: TGetSubOrgIdsBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/list_suborgs"
    val bodyJson = json.encodeToJsonElement(TGetSubOrgIdsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getTvcApps(input: TGetTvcAppsBody): TGetTvcAppsResponse {
    val url = "$apiBaseUrl/public/v1/query/list_tvc_apps"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetTvcAppsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/list_tvc_apps: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetTvcAppsResponse.serializer(), text)
    }
  }

  public suspend fun stampGetTvcApps(input: TGetTvcAppsBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/list_tvc_apps"
    val bodyJson = json.encodeToJsonElement(TGetTvcAppsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun listUserTags(input: TListUserTagsBody): TListUserTagsResponse {
    val url = "$apiBaseUrl/public/v1/query/list_user_tags"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TListUserTagsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/list_user_tags: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TListUserTagsResponse.serializer(), text)
    }
  }

  public suspend fun stampListUserTags(input: TListUserTagsBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/list_user_tags"
    val bodyJson = json.encodeToJsonElement(TListUserTagsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getUsers(input: TGetUsersBody): TGetUsersResponse {
    val url = "$apiBaseUrl/public/v1/query/list_users"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetUsersBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/list_users: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetUsersResponse.serializer(), text)
    }
  }

  public suspend fun stampGetUsers(input: TGetUsersBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/list_users"
    val bodyJson = json.encodeToJsonElement(TGetUsersBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getVerifiedSubOrgIds(input: TGetVerifiedSubOrgIdsBody): TGetVerifiedSubOrgIdsResponse {
    val url = "$apiBaseUrl/public/v1/query/list_verified_suborgs"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetVerifiedSubOrgIdsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/list_verified_suborgs: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetVerifiedSubOrgIdsResponse.serializer(), text)
    }
  }

  public suspend fun stampGetVerifiedSubOrgIds(input: TGetVerifiedSubOrgIdsBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/list_verified_suborgs"
    val bodyJson = json.encodeToJsonElement(TGetVerifiedSubOrgIdsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getWalletAccounts(input: TGetWalletAccountsBody): TGetWalletAccountsResponse {
    val url = "$apiBaseUrl/public/v1/query/list_wallet_accounts"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetWalletAccountsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/list_wallet_accounts: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetWalletAccountsResponse.serializer(), text)
    }
  }

  public suspend fun stampGetWalletAccounts(input: TGetWalletAccountsBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/list_wallet_accounts"
    val bodyJson = json.encodeToJsonElement(TGetWalletAccountsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getWallets(input: TGetWalletsBody): TGetWalletsResponse {
    val url = "$apiBaseUrl/public/v1/query/list_wallets"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetWalletsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/list_wallets: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetWalletsResponse.serializer(), text)
    }
  }

  public suspend fun stampGetWallets(input: TGetWalletsBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/list_wallets"
    val bodyJson = json.encodeToJsonElement(TGetWalletsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun getWhoami(input: TGetWhoamiBody): TGetWhoamiResponse {
    val url = "$apiBaseUrl/public/v1/query/whoami"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TGetWhoamiBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /public/v1/query/whoami: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TGetWhoamiResponse.serializer(), text)
    }
  }

  public suspend fun stampGetWhoami(input: TGetWhoamiBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/query/whoami"
    val bodyJson = json.encodeToJsonElement(TGetWhoamiBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun approveActivity(input: TApproveActivityBody): TApproveActivityResponse {
    val url = "$apiBaseUrl/public/v1/submit/approve_activity"
    val activityType = "ACTIVITY_TYPE_APPROVE_ACTIVITY"
    val activityRes = activity<TApproveActivityBody>(url, input, activityType)
    return TApproveActivityResponse(activity = activityRes)
  }

  public suspend fun stampApproveActivity(input: TApproveActivityBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/approve_activity"
    val inputElem = json.encodeToJsonElement(TApproveActivityBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_APPROVE_ACTIVITY"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun approveTvcDeployment(input: TApproveTvcDeploymentBody): TApproveTvcDeploymentResponse {
    val url = "$apiBaseUrl/public/v1/submit/approve_tvc_deployment"
    val activityType = "ACTIVITY_TYPE_APPROVE_TVC_DEPLOYMENT"
    val activityRes = activity<TApproveTvcDeploymentBody>(url, input, activityType)
    return TApproveTvcDeploymentResponse(activity = activityRes, result = activityRes.result.approveTvcDeploymentResult ?: throw RuntimeException("No result found from /public/v1/submit/approve_tvc_deployment"))
  }

  public suspend fun stampApproveTvcDeployment(input: TApproveTvcDeploymentBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/approve_tvc_deployment"
    val inputElem = json.encodeToJsonElement(TApproveTvcDeploymentBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_APPROVE_TVC_DEPLOYMENT"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun createApiKeys(input: TCreateApiKeysBody): TCreateApiKeysResponse {
    val url = "$apiBaseUrl/public/v1/submit/create_api_keys"
    val activityType = "ACTIVITY_TYPE_CREATE_API_KEYS_V2"
    val activityRes = activity<TCreateApiKeysBody>(url, input, activityType)
    return TCreateApiKeysResponse(activity = activityRes, result = activityRes.result.createApiKeysResult ?: throw RuntimeException("No result found from /public/v1/submit/create_api_keys"))
  }

  public suspend fun stampCreateApiKeys(input: TCreateApiKeysBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/create_api_keys"
    val inputElem = json.encodeToJsonElement(TCreateApiKeysBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_CREATE_API_KEYS_V2"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun createApiOnlyUsers(input: TCreateApiOnlyUsersBody): TCreateApiOnlyUsersResponse {
    val url = "$apiBaseUrl/public/v1/submit/create_api_only_users"
    val activityType = "ACTIVITY_TYPE_CREATE_API_ONLY_USERS"
    val activityRes = activity<TCreateApiOnlyUsersBody>(url, input, activityType)
    return TCreateApiOnlyUsersResponse(activity = activityRes, result = activityRes.result.createApiOnlyUsersResult ?: throw RuntimeException("No result found from /public/v1/submit/create_api_only_users"))
  }

  public suspend fun stampCreateApiOnlyUsers(input: TCreateApiOnlyUsersBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/create_api_only_users"
    val inputElem = json.encodeToJsonElement(TCreateApiOnlyUsersBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_CREATE_API_ONLY_USERS"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun createAuthenticators(input: TCreateAuthenticatorsBody): TCreateAuthenticatorsResponse {
    val url = "$apiBaseUrl/public/v1/submit/create_authenticators"
    val activityType = "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2"
    val activityRes = activity<TCreateAuthenticatorsBody>(url, input, activityType)
    return TCreateAuthenticatorsResponse(activity = activityRes, result = activityRes.result.createAuthenticatorsResult ?: throw RuntimeException("No result found from /public/v1/submit/create_authenticators"))
  }

  public suspend fun stampCreateAuthenticators(input: TCreateAuthenticatorsBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/create_authenticators"
    val inputElem = json.encodeToJsonElement(TCreateAuthenticatorsBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun createFiatOnRampCredential(input: TCreateFiatOnRampCredentialBody): TCreateFiatOnRampCredentialResponse {
    val url = "$apiBaseUrl/public/v1/submit/create_fiat_on_ramp_credential"
    val activityType = "ACTIVITY_TYPE_CREATE_FIAT_ON_RAMP_CREDENTIAL"
    val activityRes = activity<TCreateFiatOnRampCredentialBody>(url, input, activityType)
    return TCreateFiatOnRampCredentialResponse(activity = activityRes, result = activityRes.result.createFiatOnRampCredentialResult ?: throw RuntimeException("No result found from /public/v1/submit/create_fiat_on_ramp_credential"))
  }

  public suspend fun stampCreateFiatOnRampCredential(input: TCreateFiatOnRampCredentialBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/create_fiat_on_ramp_credential"
    val inputElem = json.encodeToJsonElement(TCreateFiatOnRampCredentialBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_CREATE_FIAT_ON_RAMP_CREDENTIAL"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun createInvitations(input: TCreateInvitationsBody): TCreateInvitationsResponse {
    val url = "$apiBaseUrl/public/v1/submit/create_invitations"
    val activityType = "ACTIVITY_TYPE_CREATE_INVITATIONS"
    val activityRes = activity<TCreateInvitationsBody>(url, input, activityType)
    return TCreateInvitationsResponse(activity = activityRes, result = activityRes.result.createInvitationsResult ?: throw RuntimeException("No result found from /public/v1/submit/create_invitations"))
  }

  public suspend fun stampCreateInvitations(input: TCreateInvitationsBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/create_invitations"
    val inputElem = json.encodeToJsonElement(TCreateInvitationsBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_CREATE_INVITATIONS"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun createOauth2Credential(input: TCreateOauth2CredentialBody): TCreateOauth2CredentialResponse {
    val url = "$apiBaseUrl/public/v1/submit/create_oauth2_credential"
    val activityType = "ACTIVITY_TYPE_CREATE_OAUTH2_CREDENTIAL"
    val activityRes = activity<TCreateOauth2CredentialBody>(url, input, activityType)
    return TCreateOauth2CredentialResponse(activity = activityRes, result = activityRes.result.createOauth2CredentialResult ?: throw RuntimeException("No result found from /public/v1/submit/create_oauth2_credential"))
  }

  public suspend fun stampCreateOauth2Credential(input: TCreateOauth2CredentialBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/create_oauth2_credential"
    val inputElem = json.encodeToJsonElement(TCreateOauth2CredentialBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_CREATE_OAUTH2_CREDENTIAL"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun createOauthProviders(input: TCreateOauthProvidersBody): TCreateOauthProvidersResponse {
    val url = "$apiBaseUrl/public/v1/submit/create_oauth_providers"
    val activityType = "ACTIVITY_TYPE_CREATE_OAUTH_PROVIDERS"
    val activityRes = activity<TCreateOauthProvidersBody>(url, input, activityType)
    return TCreateOauthProvidersResponse(activity = activityRes, result = activityRes.result.createOauthProvidersResult ?: throw RuntimeException("No result found from /public/v1/submit/create_oauth_providers"))
  }

  public suspend fun stampCreateOauthProviders(input: TCreateOauthProvidersBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/create_oauth_providers"
    val inputElem = json.encodeToJsonElement(TCreateOauthProvidersBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_CREATE_OAUTH_PROVIDERS"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun createPolicies(input: TCreatePoliciesBody): TCreatePoliciesResponse {
    val url = "$apiBaseUrl/public/v1/submit/create_policies"
    val activityType = "ACTIVITY_TYPE_CREATE_POLICIES"
    val activityRes = activity<TCreatePoliciesBody>(url, input, activityType)
    return TCreatePoliciesResponse(activity = activityRes, result = activityRes.result.createPoliciesResult ?: throw RuntimeException("No result found from /public/v1/submit/create_policies"))
  }

  public suspend fun stampCreatePolicies(input: TCreatePoliciesBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/create_policies"
    val inputElem = json.encodeToJsonElement(TCreatePoliciesBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_CREATE_POLICIES"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun createPolicy(input: TCreatePolicyBody): TCreatePolicyResponse {
    val url = "$apiBaseUrl/public/v1/submit/create_policy"
    val activityType = "ACTIVITY_TYPE_CREATE_POLICY_V3"
    val activityRes = activity<TCreatePolicyBody>(url, input, activityType)
    return TCreatePolicyResponse(activity = activityRes, result = activityRes.result.createPolicyResult ?: throw RuntimeException("No result found from /public/v1/submit/create_policy"))
  }

  public suspend fun stampCreatePolicy(input: TCreatePolicyBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/create_policy"
    val inputElem = json.encodeToJsonElement(TCreatePolicyBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_CREATE_POLICY_V3"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun createPrivateKeyTag(input: TCreatePrivateKeyTagBody): TCreatePrivateKeyTagResponse {
    val url = "$apiBaseUrl/public/v1/submit/create_private_key_tag"
    val activityType = "ACTIVITY_TYPE_CREATE_PRIVATE_KEY_TAG"
    val activityRes = activity<TCreatePrivateKeyTagBody>(url, input, activityType)
    return TCreatePrivateKeyTagResponse(activity = activityRes, result = activityRes.result.createPrivateKeyTagResult ?: throw RuntimeException("No result found from /public/v1/submit/create_private_key_tag"))
  }

  public suspend fun stampCreatePrivateKeyTag(input: TCreatePrivateKeyTagBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/create_private_key_tag"
    val inputElem = json.encodeToJsonElement(TCreatePrivateKeyTagBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_CREATE_PRIVATE_KEY_TAG"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun createPrivateKeys(input: TCreatePrivateKeysBody): TCreatePrivateKeysResponse {
    val url = "$apiBaseUrl/public/v1/submit/create_private_keys"
    val activityType = "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2"
    val activityRes = activity<TCreatePrivateKeysBody>(url, input, activityType)
    return TCreatePrivateKeysResponse(activity = activityRes, result = activityRes.result.createPrivateKeysResultV2 ?: throw RuntimeException("No result found from /public/v1/submit/create_private_keys"))
  }

  public suspend fun stampCreatePrivateKeys(input: TCreatePrivateKeysBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/create_private_keys"
    val inputElem = json.encodeToJsonElement(TCreatePrivateKeysBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun createReadOnlySession(input: TCreateReadOnlySessionBody): TCreateReadOnlySessionResponse {
    val url = "$apiBaseUrl/public/v1/submit/create_read_only_session"
    val activityType = "ACTIVITY_TYPE_CREATE_READ_ONLY_SESSION"
    val activityRes = activity<TCreateReadOnlySessionBody>(url, input, activityType)
    return TCreateReadOnlySessionResponse(activity = activityRes, result = activityRes.result.createReadOnlySessionResult ?: throw RuntimeException("No result found from /public/v1/submit/create_read_only_session"))
  }

  public suspend fun stampCreateReadOnlySession(input: TCreateReadOnlySessionBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/create_read_only_session"
    val inputElem = json.encodeToJsonElement(TCreateReadOnlySessionBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_CREATE_READ_ONLY_SESSION"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun createReadWriteSession(input: TCreateReadWriteSessionBody): TCreateReadWriteSessionResponse {
    val url = "$apiBaseUrl/public/v1/submit/create_read_write_session"
    val activityType = "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2"
    val activityRes = activity<TCreateReadWriteSessionBody>(url, input, activityType)
    return TCreateReadWriteSessionResponse(activity = activityRes, result = activityRes.result.createReadWriteSessionResultV2 ?: throw RuntimeException("No result found from /public/v1/submit/create_read_write_session"))
  }

  public suspend fun stampCreateReadWriteSession(input: TCreateReadWriteSessionBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/create_read_write_session"
    val inputElem = json.encodeToJsonElement(TCreateReadWriteSessionBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun createSmartContractInterface(input: TCreateSmartContractInterfaceBody): TCreateSmartContractInterfaceResponse {
    val url = "$apiBaseUrl/public/v1/submit/create_smart_contract_interface"
    val activityType = "ACTIVITY_TYPE_CREATE_SMART_CONTRACT_INTERFACE"
    val activityRes = activity<TCreateSmartContractInterfaceBody>(url, input, activityType)
    return TCreateSmartContractInterfaceResponse(activity = activityRes, result = activityRes.result.createSmartContractInterfaceResult ?: throw RuntimeException("No result found from /public/v1/submit/create_smart_contract_interface"))
  }

  public suspend fun stampCreateSmartContractInterface(input: TCreateSmartContractInterfaceBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/create_smart_contract_interface"
    val inputElem = json.encodeToJsonElement(TCreateSmartContractInterfaceBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_CREATE_SMART_CONTRACT_INTERFACE"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun createSubOrganization(input: TCreateSubOrganizationBody): TCreateSubOrganizationResponse {
    val url = "$apiBaseUrl/public/v1/submit/create_sub_organization"
    val activityType = "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7"
    val activityRes = activity<TCreateSubOrganizationBody>(url, input, activityType)
    return TCreateSubOrganizationResponse(activity = activityRes, result = activityRes.result.createSubOrganizationResultV7 ?: throw RuntimeException("No result found from /public/v1/submit/create_sub_organization"))
  }

  public suspend fun stampCreateSubOrganization(input: TCreateSubOrganizationBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/create_sub_organization"
    val inputElem = json.encodeToJsonElement(TCreateSubOrganizationBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun createTvcApp(input: TCreateTvcAppBody): TCreateTvcAppResponse {
    val url = "$apiBaseUrl/public/v1/submit/create_tvc_app"
    val activityType = "ACTIVITY_TYPE_CREATE_TVC_APP"
    val activityRes = activity<TCreateTvcAppBody>(url, input, activityType)
    return TCreateTvcAppResponse(activity = activityRes, result = activityRes.result.createTvcAppResult ?: throw RuntimeException("No result found from /public/v1/submit/create_tvc_app"))
  }

  public suspend fun stampCreateTvcApp(input: TCreateTvcAppBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/create_tvc_app"
    val inputElem = json.encodeToJsonElement(TCreateTvcAppBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_CREATE_TVC_APP"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun createTvcDeployment(input: TCreateTvcDeploymentBody): TCreateTvcDeploymentResponse {
    val url = "$apiBaseUrl/public/v1/submit/create_tvc_deployment"
    val activityType = "ACTIVITY_TYPE_CREATE_TVC_DEPLOYMENT"
    val activityRes = activity<TCreateTvcDeploymentBody>(url, input, activityType)
    return TCreateTvcDeploymentResponse(activity = activityRes, result = activityRes.result.createTvcDeploymentResult ?: throw RuntimeException("No result found from /public/v1/submit/create_tvc_deployment"))
  }

  public suspend fun stampCreateTvcDeployment(input: TCreateTvcDeploymentBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/create_tvc_deployment"
    val inputElem = json.encodeToJsonElement(TCreateTvcDeploymentBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_CREATE_TVC_DEPLOYMENT"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun createUserTag(input: TCreateUserTagBody): TCreateUserTagResponse {
    val url = "$apiBaseUrl/public/v1/submit/create_user_tag"
    val activityType = "ACTIVITY_TYPE_CREATE_USER_TAG"
    val activityRes = activity<TCreateUserTagBody>(url, input, activityType)
    return TCreateUserTagResponse(activity = activityRes, result = activityRes.result.createUserTagResult ?: throw RuntimeException("No result found from /public/v1/submit/create_user_tag"))
  }

  public suspend fun stampCreateUserTag(input: TCreateUserTagBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/create_user_tag"
    val inputElem = json.encodeToJsonElement(TCreateUserTagBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_CREATE_USER_TAG"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun createUsers(input: TCreateUsersBody): TCreateUsersResponse {
    val url = "$apiBaseUrl/public/v1/submit/create_users"
    val activityType = "ACTIVITY_TYPE_CREATE_USERS_V3"
    val activityRes = activity<TCreateUsersBody>(url, input, activityType)
    return TCreateUsersResponse(activity = activityRes, result = activityRes.result.createUsersResult ?: throw RuntimeException("No result found from /public/v1/submit/create_users"))
  }

  public suspend fun stampCreateUsers(input: TCreateUsersBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/create_users"
    val inputElem = json.encodeToJsonElement(TCreateUsersBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_CREATE_USERS_V3"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun createWallet(input: TCreateWalletBody): TCreateWalletResponse {
    val url = "$apiBaseUrl/public/v1/submit/create_wallet"
    val activityType = "ACTIVITY_TYPE_CREATE_WALLET"
    val activityRes = activity<TCreateWalletBody>(url, input, activityType)
    return TCreateWalletResponse(activity = activityRes, result = activityRes.result.createWalletResult ?: throw RuntimeException("No result found from /public/v1/submit/create_wallet"))
  }

  public suspend fun stampCreateWallet(input: TCreateWalletBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/create_wallet"
    val inputElem = json.encodeToJsonElement(TCreateWalletBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_CREATE_WALLET"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun createWalletAccounts(input: TCreateWalletAccountsBody): TCreateWalletAccountsResponse {
    val url = "$apiBaseUrl/public/v1/submit/create_wallet_accounts"
    val activityType = "ACTIVITY_TYPE_CREATE_WALLET_ACCOUNTS"
    val activityRes = activity<TCreateWalletAccountsBody>(url, input, activityType)
    return TCreateWalletAccountsResponse(activity = activityRes, result = activityRes.result.createWalletAccountsResult ?: throw RuntimeException("No result found from /public/v1/submit/create_wallet_accounts"))
  }

  public suspend fun stampCreateWalletAccounts(input: TCreateWalletAccountsBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/create_wallet_accounts"
    val inputElem = json.encodeToJsonElement(TCreateWalletAccountsBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_CREATE_WALLET_ACCOUNTS"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun deleteApiKeys(input: TDeleteApiKeysBody): TDeleteApiKeysResponse {
    val url = "$apiBaseUrl/public/v1/submit/delete_api_keys"
    val activityType = "ACTIVITY_TYPE_DELETE_API_KEYS"
    val activityRes = activity<TDeleteApiKeysBody>(url, input, activityType)
    return TDeleteApiKeysResponse(activity = activityRes, result = activityRes.result.deleteApiKeysResult ?: throw RuntimeException("No result found from /public/v1/submit/delete_api_keys"))
  }

  public suspend fun stampDeleteApiKeys(input: TDeleteApiKeysBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/delete_api_keys"
    val inputElem = json.encodeToJsonElement(TDeleteApiKeysBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_DELETE_API_KEYS"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun deleteAuthenticators(input: TDeleteAuthenticatorsBody): TDeleteAuthenticatorsResponse {
    val url = "$apiBaseUrl/public/v1/submit/delete_authenticators"
    val activityType = "ACTIVITY_TYPE_DELETE_AUTHENTICATORS"
    val activityRes = activity<TDeleteAuthenticatorsBody>(url, input, activityType)
    return TDeleteAuthenticatorsResponse(activity = activityRes, result = activityRes.result.deleteAuthenticatorsResult ?: throw RuntimeException("No result found from /public/v1/submit/delete_authenticators"))
  }

  public suspend fun stampDeleteAuthenticators(input: TDeleteAuthenticatorsBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/delete_authenticators"
    val inputElem = json.encodeToJsonElement(TDeleteAuthenticatorsBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_DELETE_AUTHENTICATORS"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun deleteFiatOnRampCredential(input: TDeleteFiatOnRampCredentialBody): TDeleteFiatOnRampCredentialResponse {
    val url = "$apiBaseUrl/public/v1/submit/delete_fiat_on_ramp_credential"
    val activityType = "ACTIVITY_TYPE_DELETE_FIAT_ON_RAMP_CREDENTIAL"
    val activityRes = activity<TDeleteFiatOnRampCredentialBody>(url, input, activityType)
    return TDeleteFiatOnRampCredentialResponse(activity = activityRes, result = activityRes.result.deleteFiatOnRampCredentialResult ?: throw RuntimeException("No result found from /public/v1/submit/delete_fiat_on_ramp_credential"))
  }

  public suspend fun stampDeleteFiatOnRampCredential(input: TDeleteFiatOnRampCredentialBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/delete_fiat_on_ramp_credential"
    val inputElem = json.encodeToJsonElement(TDeleteFiatOnRampCredentialBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_DELETE_FIAT_ON_RAMP_CREDENTIAL"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun deleteInvitation(input: TDeleteInvitationBody): TDeleteInvitationResponse {
    val url = "$apiBaseUrl/public/v1/submit/delete_invitation"
    val activityType = "ACTIVITY_TYPE_DELETE_INVITATION"
    val activityRes = activity<TDeleteInvitationBody>(url, input, activityType)
    return TDeleteInvitationResponse(activity = activityRes, result = activityRes.result.deleteInvitationResult ?: throw RuntimeException("No result found from /public/v1/submit/delete_invitation"))
  }

  public suspend fun stampDeleteInvitation(input: TDeleteInvitationBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/delete_invitation"
    val inputElem = json.encodeToJsonElement(TDeleteInvitationBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_DELETE_INVITATION"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun deleteOauth2Credential(input: TDeleteOauth2CredentialBody): TDeleteOauth2CredentialResponse {
    val url = "$apiBaseUrl/public/v1/submit/delete_oauth2_credential"
    val activityType = "ACTIVITY_TYPE_DELETE_OAUTH2_CREDENTIAL"
    val activityRes = activity<TDeleteOauth2CredentialBody>(url, input, activityType)
    return TDeleteOauth2CredentialResponse(activity = activityRes, result = activityRes.result.deleteOauth2CredentialResult ?: throw RuntimeException("No result found from /public/v1/submit/delete_oauth2_credential"))
  }

  public suspend fun stampDeleteOauth2Credential(input: TDeleteOauth2CredentialBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/delete_oauth2_credential"
    val inputElem = json.encodeToJsonElement(TDeleteOauth2CredentialBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_DELETE_OAUTH2_CREDENTIAL"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun deleteOauthProviders(input: TDeleteOauthProvidersBody): TDeleteOauthProvidersResponse {
    val url = "$apiBaseUrl/public/v1/submit/delete_oauth_providers"
    val activityType = "ACTIVITY_TYPE_DELETE_OAUTH_PROVIDERS"
    val activityRes = activity<TDeleteOauthProvidersBody>(url, input, activityType)
    return TDeleteOauthProvidersResponse(activity = activityRes, result = activityRes.result.deleteOauthProvidersResult ?: throw RuntimeException("No result found from /public/v1/submit/delete_oauth_providers"))
  }

  public suspend fun stampDeleteOauthProviders(input: TDeleteOauthProvidersBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/delete_oauth_providers"
    val inputElem = json.encodeToJsonElement(TDeleteOauthProvidersBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_DELETE_OAUTH_PROVIDERS"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun deletePolicies(input: TDeletePoliciesBody): TDeletePoliciesResponse {
    val url = "$apiBaseUrl/public/v1/submit/delete_policies"
    val activityType = "ACTIVITY_TYPE_DELETE_POLICIES"
    val activityRes = activity<TDeletePoliciesBody>(url, input, activityType)
    return TDeletePoliciesResponse(activity = activityRes, result = activityRes.result.deletePoliciesResult ?: throw RuntimeException("No result found from /public/v1/submit/delete_policies"))
  }

  public suspend fun stampDeletePolicies(input: TDeletePoliciesBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/delete_policies"
    val inputElem = json.encodeToJsonElement(TDeletePoliciesBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_DELETE_POLICIES"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun deletePolicy(input: TDeletePolicyBody): TDeletePolicyResponse {
    val url = "$apiBaseUrl/public/v1/submit/delete_policy"
    val activityType = "ACTIVITY_TYPE_DELETE_POLICY"
    val activityRes = activity<TDeletePolicyBody>(url, input, activityType)
    return TDeletePolicyResponse(activity = activityRes, result = activityRes.result.deletePolicyResult ?: throw RuntimeException("No result found from /public/v1/submit/delete_policy"))
  }

  public suspend fun stampDeletePolicy(input: TDeletePolicyBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/delete_policy"
    val inputElem = json.encodeToJsonElement(TDeletePolicyBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_DELETE_POLICY"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun deletePrivateKeyTags(input: TDeletePrivateKeyTagsBody): TDeletePrivateKeyTagsResponse {
    val url = "$apiBaseUrl/public/v1/submit/delete_private_key_tags"
    val activityType = "ACTIVITY_TYPE_DELETE_PRIVATE_KEY_TAGS"
    val activityRes = activity<TDeletePrivateKeyTagsBody>(url, input, activityType)
    return TDeletePrivateKeyTagsResponse(activity = activityRes, result = activityRes.result.deletePrivateKeyTagsResult ?: throw RuntimeException("No result found from /public/v1/submit/delete_private_key_tags"))
  }

  public suspend fun stampDeletePrivateKeyTags(input: TDeletePrivateKeyTagsBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/delete_private_key_tags"
    val inputElem = json.encodeToJsonElement(TDeletePrivateKeyTagsBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_DELETE_PRIVATE_KEY_TAGS"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun deletePrivateKeys(input: TDeletePrivateKeysBody): TDeletePrivateKeysResponse {
    val url = "$apiBaseUrl/public/v1/submit/delete_private_keys"
    val activityType = "ACTIVITY_TYPE_DELETE_PRIVATE_KEYS"
    val activityRes = activity<TDeletePrivateKeysBody>(url, input, activityType)
    return TDeletePrivateKeysResponse(activity = activityRes, result = activityRes.result.deletePrivateKeysResult ?: throw RuntimeException("No result found from /public/v1/submit/delete_private_keys"))
  }

  public suspend fun stampDeletePrivateKeys(input: TDeletePrivateKeysBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/delete_private_keys"
    val inputElem = json.encodeToJsonElement(TDeletePrivateKeysBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_DELETE_PRIVATE_KEYS"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun deleteSmartContractInterface(input: TDeleteSmartContractInterfaceBody): TDeleteSmartContractInterfaceResponse {
    val url = "$apiBaseUrl/public/v1/submit/delete_smart_contract_interface"
    val activityType = "ACTIVITY_TYPE_DELETE_SMART_CONTRACT_INTERFACE"
    val activityRes = activity<TDeleteSmartContractInterfaceBody>(url, input, activityType)
    return TDeleteSmartContractInterfaceResponse(activity = activityRes, result = activityRes.result.deleteSmartContractInterfaceResult ?: throw RuntimeException("No result found from /public/v1/submit/delete_smart_contract_interface"))
  }

  public suspend fun stampDeleteSmartContractInterface(input: TDeleteSmartContractInterfaceBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/delete_smart_contract_interface"
    val inputElem = json.encodeToJsonElement(TDeleteSmartContractInterfaceBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_DELETE_SMART_CONTRACT_INTERFACE"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun deleteSubOrganization(input: TDeleteSubOrganizationBody): TDeleteSubOrganizationResponse {
    val url = "$apiBaseUrl/public/v1/submit/delete_sub_organization"
    val activityType = "ACTIVITY_TYPE_DELETE_SUB_ORGANIZATION"
    val activityRes = activity<TDeleteSubOrganizationBody>(url, input, activityType)
    return TDeleteSubOrganizationResponse(activity = activityRes, result = activityRes.result.deleteSubOrganizationResult ?: throw RuntimeException("No result found from /public/v1/submit/delete_sub_organization"))
  }

  public suspend fun stampDeleteSubOrganization(input: TDeleteSubOrganizationBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/delete_sub_organization"
    val inputElem = json.encodeToJsonElement(TDeleteSubOrganizationBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_DELETE_SUB_ORGANIZATION"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun deleteUserTags(input: TDeleteUserTagsBody): TDeleteUserTagsResponse {
    val url = "$apiBaseUrl/public/v1/submit/delete_user_tags"
    val activityType = "ACTIVITY_TYPE_DELETE_USER_TAGS"
    val activityRes = activity<TDeleteUserTagsBody>(url, input, activityType)
    return TDeleteUserTagsResponse(activity = activityRes, result = activityRes.result.deleteUserTagsResult ?: throw RuntimeException("No result found from /public/v1/submit/delete_user_tags"))
  }

  public suspend fun stampDeleteUserTags(input: TDeleteUserTagsBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/delete_user_tags"
    val inputElem = json.encodeToJsonElement(TDeleteUserTagsBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_DELETE_USER_TAGS"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun deleteUsers(input: TDeleteUsersBody): TDeleteUsersResponse {
    val url = "$apiBaseUrl/public/v1/submit/delete_users"
    val activityType = "ACTIVITY_TYPE_DELETE_USERS"
    val activityRes = activity<TDeleteUsersBody>(url, input, activityType)
    return TDeleteUsersResponse(activity = activityRes, result = activityRes.result.deleteUsersResult ?: throw RuntimeException("No result found from /public/v1/submit/delete_users"))
  }

  public suspend fun stampDeleteUsers(input: TDeleteUsersBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/delete_users"
    val inputElem = json.encodeToJsonElement(TDeleteUsersBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_DELETE_USERS"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun deleteWalletAccounts(input: TDeleteWalletAccountsBody): TDeleteWalletAccountsResponse {
    val url = "$apiBaseUrl/public/v1/submit/delete_wallet_accounts"
    val activityType = "ACTIVITY_TYPE_DELETE_WALLET_ACCOUNTS"
    val activityRes = activity<TDeleteWalletAccountsBody>(url, input, activityType)
    return TDeleteWalletAccountsResponse(activity = activityRes, result = activityRes.result.deleteWalletAccountsResult ?: throw RuntimeException("No result found from /public/v1/submit/delete_wallet_accounts"))
  }

  public suspend fun stampDeleteWalletAccounts(input: TDeleteWalletAccountsBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/delete_wallet_accounts"
    val inputElem = json.encodeToJsonElement(TDeleteWalletAccountsBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_DELETE_WALLET_ACCOUNTS"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun deleteWallets(input: TDeleteWalletsBody): TDeleteWalletsResponse {
    val url = "$apiBaseUrl/public/v1/submit/delete_wallets"
    val activityType = "ACTIVITY_TYPE_DELETE_WALLETS"
    val activityRes = activity<TDeleteWalletsBody>(url, input, activityType)
    return TDeleteWalletsResponse(activity = activityRes, result = activityRes.result.deleteWalletsResult ?: throw RuntimeException("No result found from /public/v1/submit/delete_wallets"))
  }

  public suspend fun stampDeleteWallets(input: TDeleteWalletsBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/delete_wallets"
    val inputElem = json.encodeToJsonElement(TDeleteWalletsBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_DELETE_WALLETS"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun emailAuth(input: TEmailAuthBody): TEmailAuthResponse {
    val url = "$apiBaseUrl/public/v1/submit/email_auth"
    val activityType = "ACTIVITY_TYPE_EMAIL_AUTH_V3"
    val activityRes = activity<TEmailAuthBody>(url, input, activityType)
    return TEmailAuthResponse(activity = activityRes, result = activityRes.result.emailAuthResult ?: throw RuntimeException("No result found from /public/v1/submit/email_auth"))
  }

  public suspend fun stampEmailAuth(input: TEmailAuthBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/email_auth"
    val inputElem = json.encodeToJsonElement(TEmailAuthBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_EMAIL_AUTH_V3"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun ethSendRawTransaction(input: TEthSendRawTransactionBody): TEthSendRawTransactionResponse {
    val url = "$apiBaseUrl/public/v1/submit/eth_send_raw_transaction"
    val activityType = "ACTIVITY_TYPE_ETH_SEND_RAW_TRANSACTION"
    val activityRes = activity<TEthSendRawTransactionBody>(url, input, activityType)
    return TEthSendRawTransactionResponse(activity = activityRes, result = activityRes.result.ethSendRawTransactionResult ?: throw RuntimeException("No result found from /public/v1/submit/eth_send_raw_transaction"))
  }

  public suspend fun stampEthSendRawTransaction(input: TEthSendRawTransactionBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/eth_send_raw_transaction"
    val inputElem = json.encodeToJsonElement(TEthSendRawTransactionBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_ETH_SEND_RAW_TRANSACTION"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun ethSendTransaction(input: TEthSendTransactionBody): TEthSendTransactionResponse {
    val url = "$apiBaseUrl/public/v1/submit/eth_send_transaction"
    val activityType = "ACTIVITY_TYPE_ETH_SEND_TRANSACTION"
    val activityRes = activity<TEthSendTransactionBody>(url, input, activityType)
    return TEthSendTransactionResponse(activity = activityRes, result = activityRes.result.ethSendTransactionResult ?: throw RuntimeException("No result found from /public/v1/submit/eth_send_transaction"))
  }

  public suspend fun stampEthSendTransaction(input: TEthSendTransactionBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/eth_send_transaction"
    val inputElem = json.encodeToJsonElement(TEthSendTransactionBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_ETH_SEND_TRANSACTION"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun exportPrivateKey(input: TExportPrivateKeyBody): TExportPrivateKeyResponse {
    val url = "$apiBaseUrl/public/v1/submit/export_private_key"
    val activityType = "ACTIVITY_TYPE_EXPORT_PRIVATE_KEY"
    val activityRes = activity<TExportPrivateKeyBody>(url, input, activityType)
    return TExportPrivateKeyResponse(activity = activityRes, result = activityRes.result.exportPrivateKeyResult ?: throw RuntimeException("No result found from /public/v1/submit/export_private_key"))
  }

  public suspend fun stampExportPrivateKey(input: TExportPrivateKeyBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/export_private_key"
    val inputElem = json.encodeToJsonElement(TExportPrivateKeyBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_EXPORT_PRIVATE_KEY"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun exportWallet(input: TExportWalletBody): TExportWalletResponse {
    val url = "$apiBaseUrl/public/v1/submit/export_wallet"
    val activityType = "ACTIVITY_TYPE_EXPORT_WALLET"
    val activityRes = activity<TExportWalletBody>(url, input, activityType)
    return TExportWalletResponse(activity = activityRes, result = activityRes.result.exportWalletResult ?: throw RuntimeException("No result found from /public/v1/submit/export_wallet"))
  }

  public suspend fun stampExportWallet(input: TExportWalletBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/export_wallet"
    val inputElem = json.encodeToJsonElement(TExportWalletBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_EXPORT_WALLET"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun exportWalletAccount(input: TExportWalletAccountBody): TExportWalletAccountResponse {
    val url = "$apiBaseUrl/public/v1/submit/export_wallet_account"
    val activityType = "ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT"
    val activityRes = activity<TExportWalletAccountBody>(url, input, activityType)
    return TExportWalletAccountResponse(activity = activityRes, result = activityRes.result.exportWalletAccountResult ?: throw RuntimeException("No result found from /public/v1/submit/export_wallet_account"))
  }

  public suspend fun stampExportWalletAccount(input: TExportWalletAccountBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/export_wallet_account"
    val inputElem = json.encodeToJsonElement(TExportWalletAccountBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun importPrivateKey(input: TImportPrivateKeyBody): TImportPrivateKeyResponse {
    val url = "$apiBaseUrl/public/v1/submit/import_private_key"
    val activityType = "ACTIVITY_TYPE_IMPORT_PRIVATE_KEY"
    val activityRes = activity<TImportPrivateKeyBody>(url, input, activityType)
    return TImportPrivateKeyResponse(activity = activityRes, result = activityRes.result.importPrivateKeyResult ?: throw RuntimeException("No result found from /public/v1/submit/import_private_key"))
  }

  public suspend fun stampImportPrivateKey(input: TImportPrivateKeyBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/import_private_key"
    val inputElem = json.encodeToJsonElement(TImportPrivateKeyBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_IMPORT_PRIVATE_KEY"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun importWallet(input: TImportWalletBody): TImportWalletResponse {
    val url = "$apiBaseUrl/public/v1/submit/import_wallet"
    val activityType = "ACTIVITY_TYPE_IMPORT_WALLET"
    val activityRes = activity<TImportWalletBody>(url, input, activityType)
    return TImportWalletResponse(activity = activityRes, result = activityRes.result.importWalletResult ?: throw RuntimeException("No result found from /public/v1/submit/import_wallet"))
  }

  public suspend fun stampImportWallet(input: TImportWalletBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/import_wallet"
    val inputElem = json.encodeToJsonElement(TImportWalletBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_IMPORT_WALLET"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun initFiatOnRamp(input: TInitFiatOnRampBody): TInitFiatOnRampResponse {
    val url = "$apiBaseUrl/public/v1/submit/init_fiat_on_ramp"
    val activityType = "ACTIVITY_TYPE_INIT_FIAT_ON_RAMP"
    val activityRes = activity<TInitFiatOnRampBody>(url, input, activityType)
    return TInitFiatOnRampResponse(activity = activityRes, result = activityRes.result.initFiatOnRampResult ?: throw RuntimeException("No result found from /public/v1/submit/init_fiat_on_ramp"))
  }

  public suspend fun stampInitFiatOnRamp(input: TInitFiatOnRampBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/init_fiat_on_ramp"
    val inputElem = json.encodeToJsonElement(TInitFiatOnRampBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_INIT_FIAT_ON_RAMP"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun initImportPrivateKey(input: TInitImportPrivateKeyBody): TInitImportPrivateKeyResponse {
    val url = "$apiBaseUrl/public/v1/submit/init_import_private_key"
    val activityType = "ACTIVITY_TYPE_INIT_IMPORT_PRIVATE_KEY"
    val activityRes = activity<TInitImportPrivateKeyBody>(url, input, activityType)
    return TInitImportPrivateKeyResponse(activity = activityRes, result = activityRes.result.initImportPrivateKeyResult ?: throw RuntimeException("No result found from /public/v1/submit/init_import_private_key"))
  }

  public suspend fun stampInitImportPrivateKey(input: TInitImportPrivateKeyBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/init_import_private_key"
    val inputElem = json.encodeToJsonElement(TInitImportPrivateKeyBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_INIT_IMPORT_PRIVATE_KEY"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun initImportWallet(input: TInitImportWalletBody): TInitImportWalletResponse {
    val url = "$apiBaseUrl/public/v1/submit/init_import_wallet"
    val activityType = "ACTIVITY_TYPE_INIT_IMPORT_WALLET"
    val activityRes = activity<TInitImportWalletBody>(url, input, activityType)
    return TInitImportWalletResponse(activity = activityRes, result = activityRes.result.initImportWalletResult ?: throw RuntimeException("No result found from /public/v1/submit/init_import_wallet"))
  }

  public suspend fun stampInitImportWallet(input: TInitImportWalletBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/init_import_wallet"
    val inputElem = json.encodeToJsonElement(TInitImportWalletBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_INIT_IMPORT_WALLET"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun initOtp(input: TInitOtpBody): TInitOtpResponse {
    val url = "$apiBaseUrl/public/v1/submit/init_otp"
    val activityType = "ACTIVITY_TYPE_INIT_OTP_V2"
    val activityRes = activity<TInitOtpBody>(url, input, activityType)
    return TInitOtpResponse(activity = activityRes, result = activityRes.result.initOtpResult ?: throw RuntimeException("No result found from /public/v1/submit/init_otp"))
  }

  public suspend fun stampInitOtp(input: TInitOtpBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/init_otp"
    val inputElem = json.encodeToJsonElement(TInitOtpBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_INIT_OTP_V2"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun initOtpAuth(input: TInitOtpAuthBody): TInitOtpAuthResponse {
    val url = "$apiBaseUrl/public/v1/submit/init_otp_auth"
    val activityType = "ACTIVITY_TYPE_INIT_OTP_AUTH_V3"
    val activityRes = activity<TInitOtpAuthBody>(url, input, activityType)
    return TInitOtpAuthResponse(activity = activityRes, result = activityRes.result.initOtpAuthResultV2 ?: throw RuntimeException("No result found from /public/v1/submit/init_otp_auth"))
  }

  public suspend fun stampInitOtpAuth(input: TInitOtpAuthBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/init_otp_auth"
    val inputElem = json.encodeToJsonElement(TInitOtpAuthBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_INIT_OTP_AUTH_V3"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun initUserEmailRecovery(input: TInitUserEmailRecoveryBody): TInitUserEmailRecoveryResponse {
    val url = "$apiBaseUrl/public/v1/submit/init_user_email_recovery"
    val activityType = "ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY_V2"
    val activityRes = activity<TInitUserEmailRecoveryBody>(url, input, activityType)
    return TInitUserEmailRecoveryResponse(activity = activityRes, result = activityRes.result.initUserEmailRecoveryResult ?: throw RuntimeException("No result found from /public/v1/submit/init_user_email_recovery"))
  }

  public suspend fun stampInitUserEmailRecovery(input: TInitUserEmailRecoveryBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/init_user_email_recovery"
    val inputElem = json.encodeToJsonElement(TInitUserEmailRecoveryBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY_V2"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun oauth(input: TOauthBody): TOauthResponse {
    val url = "$apiBaseUrl/public/v1/submit/oauth"
    val activityType = "ACTIVITY_TYPE_OAUTH"
    val activityRes = activity<TOauthBody>(url, input, activityType)
    return TOauthResponse(activity = activityRes, result = activityRes.result.oauthResult ?: throw RuntimeException("No result found from /public/v1/submit/oauth"))
  }

  public suspend fun stampOauth(input: TOauthBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/oauth"
    val inputElem = json.encodeToJsonElement(TOauthBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_OAUTH"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun oauth2Authenticate(input: TOauth2AuthenticateBody): TOauth2AuthenticateResponse {
    val url = "$apiBaseUrl/public/v1/submit/oauth2_authenticate"
    val activityType = "ACTIVITY_TYPE_OAUTH2_AUTHENTICATE"
    val activityRes = activity<TOauth2AuthenticateBody>(url, input, activityType)
    return TOauth2AuthenticateResponse(activity = activityRes, result = activityRes.result.oauth2AuthenticateResult ?: throw RuntimeException("No result found from /public/v1/submit/oauth2_authenticate"))
  }

  public suspend fun stampOauth2Authenticate(input: TOauth2AuthenticateBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/oauth2_authenticate"
    val inputElem = json.encodeToJsonElement(TOauth2AuthenticateBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_OAUTH2_AUTHENTICATE"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun oauthLogin(input: TOauthLoginBody): TOauthLoginResponse {
    val url = "$apiBaseUrl/public/v1/submit/oauth_login"
    val activityType = "ACTIVITY_TYPE_OAUTH_LOGIN"
    val activityRes = activity<TOauthLoginBody>(url, input, activityType)
    return TOauthLoginResponse(activity = activityRes, result = activityRes.result.oauthLoginResult ?: throw RuntimeException("No result found from /public/v1/submit/oauth_login"))
  }

  public suspend fun stampOauthLogin(input: TOauthLoginBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/oauth_login"
    val inputElem = json.encodeToJsonElement(TOauthLoginBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_OAUTH_LOGIN"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun otpAuth(input: TOtpAuthBody): TOtpAuthResponse {
    val url = "$apiBaseUrl/public/v1/submit/otp_auth"
    val activityType = "ACTIVITY_TYPE_OTP_AUTH"
    val activityRes = activity<TOtpAuthBody>(url, input, activityType)
    return TOtpAuthResponse(activity = activityRes, result = activityRes.result.otpAuthResult ?: throw RuntimeException("No result found from /public/v1/submit/otp_auth"))
  }

  public suspend fun stampOtpAuth(input: TOtpAuthBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/otp_auth"
    val inputElem = json.encodeToJsonElement(TOtpAuthBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_OTP_AUTH"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun otpLogin(input: TOtpLoginBody): TOtpLoginResponse {
    val url = "$apiBaseUrl/public/v1/submit/otp_login"
    val activityType = "ACTIVITY_TYPE_OTP_LOGIN"
    val activityRes = activity<TOtpLoginBody>(url, input, activityType)
    return TOtpLoginResponse(activity = activityRes, result = activityRes.result.otpLoginResult ?: throw RuntimeException("No result found from /public/v1/submit/otp_login"))
  }

  public suspend fun stampOtpLogin(input: TOtpLoginBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/otp_login"
    val inputElem = json.encodeToJsonElement(TOtpLoginBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_OTP_LOGIN"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun recoverUser(input: TRecoverUserBody): TRecoverUserResponse {
    val url = "$apiBaseUrl/public/v1/submit/recover_user"
    val activityType = "ACTIVITY_TYPE_RECOVER_USER"
    val activityRes = activity<TRecoverUserBody>(url, input, activityType)
    return TRecoverUserResponse(activity = activityRes, result = activityRes.result.recoverUserResult ?: throw RuntimeException("No result found from /public/v1/submit/recover_user"))
  }

  public suspend fun stampRecoverUser(input: TRecoverUserBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/recover_user"
    val inputElem = json.encodeToJsonElement(TRecoverUserBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_RECOVER_USER"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun rejectActivity(input: TRejectActivityBody): TRejectActivityResponse {
    val url = "$apiBaseUrl/public/v1/submit/reject_activity"
    val activityType = "ACTIVITY_TYPE_REJECT_ACTIVITY"
    val activityRes = activity<TRejectActivityBody>(url, input, activityType)
    return TRejectActivityResponse(activity = activityRes)
  }

  public suspend fun stampRejectActivity(input: TRejectActivityBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/reject_activity"
    val inputElem = json.encodeToJsonElement(TRejectActivityBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_REJECT_ACTIVITY"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun removeOrganizationFeature(input: TRemoveOrganizationFeatureBody): TRemoveOrganizationFeatureResponse {
    val url = "$apiBaseUrl/public/v1/submit/remove_organization_feature"
    val activityType = "ACTIVITY_TYPE_REMOVE_ORGANIZATION_FEATURE"
    val activityRes = activity<TRemoveOrganizationFeatureBody>(url, input, activityType)
    return TRemoveOrganizationFeatureResponse(activity = activityRes, result = activityRes.result.removeOrganizationFeatureResult ?: throw RuntimeException("No result found from /public/v1/submit/remove_organization_feature"))
  }

  public suspend fun stampRemoveOrganizationFeature(input: TRemoveOrganizationFeatureBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/remove_organization_feature"
    val inputElem = json.encodeToJsonElement(TRemoveOrganizationFeatureBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_REMOVE_ORGANIZATION_FEATURE"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun setOrganizationFeature(input: TSetOrganizationFeatureBody): TSetOrganizationFeatureResponse {
    val url = "$apiBaseUrl/public/v1/submit/set_organization_feature"
    val activityType = "ACTIVITY_TYPE_SET_ORGANIZATION_FEATURE"
    val activityRes = activity<TSetOrganizationFeatureBody>(url, input, activityType)
    return TSetOrganizationFeatureResponse(activity = activityRes, result = activityRes.result.setOrganizationFeatureResult ?: throw RuntimeException("No result found from /public/v1/submit/set_organization_feature"))
  }

  public suspend fun stampSetOrganizationFeature(input: TSetOrganizationFeatureBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/set_organization_feature"
    val inputElem = json.encodeToJsonElement(TSetOrganizationFeatureBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_SET_ORGANIZATION_FEATURE"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun signRawPayload(input: TSignRawPayloadBody): TSignRawPayloadResponse {
    val url = "$apiBaseUrl/public/v1/submit/sign_raw_payload"
    val activityType = "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2"
    val activityRes = activity<TSignRawPayloadBody>(url, input, activityType)
    return TSignRawPayloadResponse(activity = activityRes, result = activityRes.result.signRawPayloadResult ?: throw RuntimeException("No result found from /public/v1/submit/sign_raw_payload"))
  }

  public suspend fun stampSignRawPayload(input: TSignRawPayloadBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/sign_raw_payload"
    val inputElem = json.encodeToJsonElement(TSignRawPayloadBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun signRawPayloads(input: TSignRawPayloadsBody): TSignRawPayloadsResponse {
    val url = "$apiBaseUrl/public/v1/submit/sign_raw_payloads"
    val activityType = "ACTIVITY_TYPE_SIGN_RAW_PAYLOADS"
    val activityRes = activity<TSignRawPayloadsBody>(url, input, activityType)
    return TSignRawPayloadsResponse(activity = activityRes, result = activityRes.result.signRawPayloadsResult ?: throw RuntimeException("No result found from /public/v1/submit/sign_raw_payloads"))
  }

  public suspend fun stampSignRawPayloads(input: TSignRawPayloadsBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/sign_raw_payloads"
    val inputElem = json.encodeToJsonElement(TSignRawPayloadsBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_SIGN_RAW_PAYLOADS"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun signTransaction(input: TSignTransactionBody): TSignTransactionResponse {
    val url = "$apiBaseUrl/public/v1/submit/sign_transaction"
    val activityType = "ACTIVITY_TYPE_SIGN_TRANSACTION_V2"
    val activityRes = activity<TSignTransactionBody>(url, input, activityType)
    return TSignTransactionResponse(activity = activityRes, result = activityRes.result.signTransactionResult ?: throw RuntimeException("No result found from /public/v1/submit/sign_transaction"))
  }

  public suspend fun stampSignTransaction(input: TSignTransactionBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/sign_transaction"
    val inputElem = json.encodeToJsonElement(TSignTransactionBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_SIGN_TRANSACTION_V2"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun stampLogin(input: TStampLoginBody): TStampLoginResponse {
    val url = "$apiBaseUrl/public/v1/submit/stamp_login"
    val activityType = "ACTIVITY_TYPE_STAMP_LOGIN"
    val activityRes = activity<TStampLoginBody>(url, input, activityType)
    return TStampLoginResponse(activity = activityRes, result = activityRes.result.stampLoginResult ?: throw RuntimeException("No result found from /public/v1/submit/stamp_login"))
  }

  public suspend fun stampStampLogin(input: TStampLoginBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/stamp_login"
    val inputElem = json.encodeToJsonElement(TStampLoginBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_STAMP_LOGIN"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun updateFiatOnRampCredential(input: TUpdateFiatOnRampCredentialBody): TUpdateFiatOnRampCredentialResponse {
    val url = "$apiBaseUrl/public/v1/submit/update_fiat_on_ramp_credential"
    val activityType = "ACTIVITY_TYPE_UPDATE_FIAT_ON_RAMP_CREDENTIAL"
    val activityRes = activity<TUpdateFiatOnRampCredentialBody>(url, input, activityType)
    return TUpdateFiatOnRampCredentialResponse(activity = activityRes, result = activityRes.result.updateFiatOnRampCredentialResult ?: throw RuntimeException("No result found from /public/v1/submit/update_fiat_on_ramp_credential"))
  }

  public suspend fun stampUpdateFiatOnRampCredential(input: TUpdateFiatOnRampCredentialBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/update_fiat_on_ramp_credential"
    val inputElem = json.encodeToJsonElement(TUpdateFiatOnRampCredentialBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_UPDATE_FIAT_ON_RAMP_CREDENTIAL"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun updateOauth2Credential(input: TUpdateOauth2CredentialBody): TUpdateOauth2CredentialResponse {
    val url = "$apiBaseUrl/public/v1/submit/update_oauth2_credential"
    val activityType = "ACTIVITY_TYPE_UPDATE_OAUTH2_CREDENTIAL"
    val activityRes = activity<TUpdateOauth2CredentialBody>(url, input, activityType)
    return TUpdateOauth2CredentialResponse(activity = activityRes, result = activityRes.result.updateOauth2CredentialResult ?: throw RuntimeException("No result found from /public/v1/submit/update_oauth2_credential"))
  }

  public suspend fun stampUpdateOauth2Credential(input: TUpdateOauth2CredentialBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/update_oauth2_credential"
    val inputElem = json.encodeToJsonElement(TUpdateOauth2CredentialBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_UPDATE_OAUTH2_CREDENTIAL"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun updatePolicy(input: TUpdatePolicyBody): TUpdatePolicyResponse {
    val url = "$apiBaseUrl/public/v1/submit/update_policy"
    val activityType = "ACTIVITY_TYPE_UPDATE_POLICY_V2"
    val activityRes = activity<TUpdatePolicyBody>(url, input, activityType)
    return TUpdatePolicyResponse(activity = activityRes, result = activityRes.result.updatePolicyResultV2 ?: throw RuntimeException("No result found from /public/v1/submit/update_policy"))
  }

  public suspend fun stampUpdatePolicy(input: TUpdatePolicyBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/update_policy"
    val inputElem = json.encodeToJsonElement(TUpdatePolicyBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_UPDATE_POLICY_V2"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun updatePrivateKeyTag(input: TUpdatePrivateKeyTagBody): TUpdatePrivateKeyTagResponse {
    val url = "$apiBaseUrl/public/v1/submit/update_private_key_tag"
    val activityType = "ACTIVITY_TYPE_UPDATE_PRIVATE_KEY_TAG"
    val activityRes = activity<TUpdatePrivateKeyTagBody>(url, input, activityType)
    return TUpdatePrivateKeyTagResponse(activity = activityRes, result = activityRes.result.updatePrivateKeyTagResult ?: throw RuntimeException("No result found from /public/v1/submit/update_private_key_tag"))
  }

  public suspend fun stampUpdatePrivateKeyTag(input: TUpdatePrivateKeyTagBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/update_private_key_tag"
    val inputElem = json.encodeToJsonElement(TUpdatePrivateKeyTagBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_UPDATE_PRIVATE_KEY_TAG"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun updateRootQuorum(input: TUpdateRootQuorumBody): TUpdateRootQuorumResponse {
    val url = "$apiBaseUrl/public/v1/submit/update_root_quorum"
    val activityType = "ACTIVITY_TYPE_UPDATE_ROOT_QUORUM"
    val activityRes = activity<TUpdateRootQuorumBody>(url, input, activityType)
    return TUpdateRootQuorumResponse(activity = activityRes, result = activityRes.result.updateRootQuorumResult ?: throw RuntimeException("No result found from /public/v1/submit/update_root_quorum"))
  }

  public suspend fun stampUpdateRootQuorum(input: TUpdateRootQuorumBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/update_root_quorum"
    val inputElem = json.encodeToJsonElement(TUpdateRootQuorumBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_UPDATE_ROOT_QUORUM"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun updateUser(input: TUpdateUserBody): TUpdateUserResponse {
    val url = "$apiBaseUrl/public/v1/submit/update_user"
    val activityType = "ACTIVITY_TYPE_UPDATE_USER"
    val activityRes = activity<TUpdateUserBody>(url, input, activityType)
    return TUpdateUserResponse(activity = activityRes, result = activityRes.result.updateUserResult ?: throw RuntimeException("No result found from /public/v1/submit/update_user"))
  }

  public suspend fun stampUpdateUser(input: TUpdateUserBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/update_user"
    val inputElem = json.encodeToJsonElement(TUpdateUserBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_UPDATE_USER"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun updateUserEmail(input: TUpdateUserEmailBody): TUpdateUserEmailResponse {
    val url = "$apiBaseUrl/public/v1/submit/update_user_email"
    val activityType = "ACTIVITY_TYPE_UPDATE_USER_EMAIL"
    val activityRes = activity<TUpdateUserEmailBody>(url, input, activityType)
    return TUpdateUserEmailResponse(activity = activityRes, result = activityRes.result.updateUserEmailResult ?: throw RuntimeException("No result found from /public/v1/submit/update_user_email"))
  }

  public suspend fun stampUpdateUserEmail(input: TUpdateUserEmailBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/update_user_email"
    val inputElem = json.encodeToJsonElement(TUpdateUserEmailBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_UPDATE_USER_EMAIL"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun updateUserName(input: TUpdateUserNameBody): TUpdateUserNameResponse {
    val url = "$apiBaseUrl/public/v1/submit/update_user_name"
    val activityType = "ACTIVITY_TYPE_UPDATE_USER_NAME"
    val activityRes = activity<TUpdateUserNameBody>(url, input, activityType)
    return TUpdateUserNameResponse(activity = activityRes, result = activityRes.result.updateUserNameResult ?: throw RuntimeException("No result found from /public/v1/submit/update_user_name"))
  }

  public suspend fun stampUpdateUserName(input: TUpdateUserNameBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/update_user_name"
    val inputElem = json.encodeToJsonElement(TUpdateUserNameBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_UPDATE_USER_NAME"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun updateUserPhoneNumber(input: TUpdateUserPhoneNumberBody): TUpdateUserPhoneNumberResponse {
    val url = "$apiBaseUrl/public/v1/submit/update_user_phone_number"
    val activityType = "ACTIVITY_TYPE_UPDATE_USER_PHONE_NUMBER"
    val activityRes = activity<TUpdateUserPhoneNumberBody>(url, input, activityType)
    return TUpdateUserPhoneNumberResponse(activity = activityRes, result = activityRes.result.updateUserPhoneNumberResult ?: throw RuntimeException("No result found from /public/v1/submit/update_user_phone_number"))
  }

  public suspend fun stampUpdateUserPhoneNumber(input: TUpdateUserPhoneNumberBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/update_user_phone_number"
    val inputElem = json.encodeToJsonElement(TUpdateUserPhoneNumberBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_UPDATE_USER_PHONE_NUMBER"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun updateUserTag(input: TUpdateUserTagBody): TUpdateUserTagResponse {
    val url = "$apiBaseUrl/public/v1/submit/update_user_tag"
    val activityType = "ACTIVITY_TYPE_UPDATE_USER_TAG"
    val activityRes = activity<TUpdateUserTagBody>(url, input, activityType)
    return TUpdateUserTagResponse(activity = activityRes, result = activityRes.result.updateUserTagResult ?: throw RuntimeException("No result found from /public/v1/submit/update_user_tag"))
  }

  public suspend fun stampUpdateUserTag(input: TUpdateUserTagBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/update_user_tag"
    val inputElem = json.encodeToJsonElement(TUpdateUserTagBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_UPDATE_USER_TAG"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun updateWallet(input: TUpdateWalletBody): TUpdateWalletResponse {
    val url = "$apiBaseUrl/public/v1/submit/update_wallet"
    val activityType = "ACTIVITY_TYPE_UPDATE_WALLET"
    val activityRes = activity<TUpdateWalletBody>(url, input, activityType)
    return TUpdateWalletResponse(activity = activityRes, result = activityRes.result.updateWalletResult ?: throw RuntimeException("No result found from /public/v1/submit/update_wallet"))
  }

  public suspend fun stampUpdateWallet(input: TUpdateWalletBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/update_wallet"
    val inputElem = json.encodeToJsonElement(TUpdateWalletBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_UPDATE_WALLET"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun verifyOtp(input: TVerifyOtpBody): TVerifyOtpResponse {
    val url = "$apiBaseUrl/public/v1/submit/verify_otp"
    val activityType = "ACTIVITY_TYPE_VERIFY_OTP"
    val activityRes = activity<TVerifyOtpBody>(url, input, activityType)
    return TVerifyOtpResponse(activity = activityRes, result = activityRes.result.verifyOtpResult ?: throw RuntimeException("No result found from /public/v1/submit/verify_otp"))
  }

  public suspend fun stampVerifyOtp(input: TVerifyOtpBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/public/v1/submit/verify_otp"
    val inputElem = json.encodeToJsonElement(TVerifyOtpBody.serializer(), input)
    val obj = inputElem.jsonObject
    val inputOrgId = obj["organizationId"]
    val inputTimestamp = obj["timestampMs"]
    val params = kotlinx.serialization.json.buildJsonObject { obj.forEach { (k, v) -> if (k != "organizationId" && k != "timestampMs") put(k, v) } }
    val ts = inputTimestamp?.jsonPrimitive?.content ?: System.currentTimeMillis().toString()
    val activityType = "ACTIVITY_TYPE_VERIFY_OTP"
    val bodyObj = kotlinx.serialization.json.buildJsonObject { put("parameters", params); inputOrgId?.let { put("organizationId", it) }; put("timestampMs", kotlinx.serialization.json.JsonPrimitive(ts)); put("type", kotlinx.serialization.json.JsonPrimitive(activityType)) }
    val bodyJson = json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), bodyObj)
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun nOOPCodegenAnchor(): TNOOPCodegenAnchorResponse {
    val url = "$apiBaseUrl/tkhq/api/v1/noop-codegen-anchor"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = "{}"
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /tkhq/api/v1/noop-codegen-anchor: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TNOOPCodegenAnchorResponse.serializer(), text)
    }
  }

  public suspend fun stampNOOPCodegenAnchor(): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/tkhq/api/v1/noop-codegen-anchor"
    val bodyJson = ""
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun testRateLimits(input: TTestRateLimitsBody): TTestRateLimitsResponse {
    val url = "$apiBaseUrl/tkhq/api/v1/test_rate_limits"
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val bodyJson = json.encodeToJsonElement(TTestRateLimitsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header(hName, hValue).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /tkhq/api/v1/test_rate_limits: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(TTestRateLimitsResponse.serializer(), text)
    }
  }

  public suspend fun stampTestRateLimits(input: TTestRateLimitsBody): TSignedRequest {
    if (stamper == null) throw TurnkeyHttpError.StamperNotInitialized()
    val url = "$apiBaseUrl/tkhq/api/v1/test_rate_limits"
    val bodyJson = json.encodeToJsonElement(TTestRateLimitsBody.serializer(), input).jsonObject.let { obj -> kotlinx.serialization.json.buildJsonObject { obj.filterKeys { it != "organizationId" }.forEach { (k, v) -> put(k, v) }; put("organizationId", obj["organizationId"] ?: kotlinx.serialization.json.JsonPrimitive(organizationId)) } }.let { json.encodeToString(kotlinx.serialization.json.JsonObject.serializer(), it) }
    val (hName, hValue) = stamper.stamp(bodyJson)
    val stamp = TStamp(stampHeaderName = hName, stampHeaderValue = hValue)
    return TSignedRequest(body = bodyJson, stamp = stamp, url = url)
  }

  public suspend fun proxyGetAccount(input: ProxyTGetAccountBody): ProxyTGetAccountResponse {
    val url = "$authProxyUrl/v1/account"
    if (authProxyConfigId.isNullOrBlank()) throw TurnkeyHttpError.MissingAuthProxyConfigId()
    val bodyJson = json.encodeToString(ProxyTGetAccountBody.serializer(), input)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header("X-Auth-Proxy-Config-ID", authProxyConfigId).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /v1/account: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(ProxyTGetAccountResponse.serializer(), text)
    }
  }

  public suspend fun proxyOAuth2Authenticate(input: ProxyTOAuth2AuthenticateBody): ProxyTOAuth2AuthenticateResponse {
    val url = "$authProxyUrl/v1/oauth2_authenticate"
    if (authProxyConfigId.isNullOrBlank()) throw TurnkeyHttpError.MissingAuthProxyConfigId()
    val bodyJson = json.encodeToString(ProxyTOAuth2AuthenticateBody.serializer(), input)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header("X-Auth-Proxy-Config-ID", authProxyConfigId).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /v1/oauth2_authenticate: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(ProxyTOAuth2AuthenticateResponse.serializer(), text)
    }
  }

  public suspend fun proxyOAuthLogin(input: ProxyTOAuthLoginBody): ProxyTOAuthLoginResponse {
    val url = "$authProxyUrl/v1/oauth_login"
    if (authProxyConfigId.isNullOrBlank()) throw TurnkeyHttpError.MissingAuthProxyConfigId()
    val bodyJson = json.encodeToString(ProxyTOAuthLoginBody.serializer(), input)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header("X-Auth-Proxy-Config-ID", authProxyConfigId).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /v1/oauth_login: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(ProxyTOAuthLoginResponse.serializer(), text)
    }
  }

  public suspend fun proxyInitOtp(input: ProxyTInitOtpBody): ProxyTInitOtpResponse {
    val url = "$authProxyUrl/v1/otp_init"
    if (authProxyConfigId.isNullOrBlank()) throw TurnkeyHttpError.MissingAuthProxyConfigId()
    val bodyJson = json.encodeToString(ProxyTInitOtpBody.serializer(), input)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header("X-Auth-Proxy-Config-ID", authProxyConfigId).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /v1/otp_init: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(ProxyTInitOtpResponse.serializer(), text)
    }
  }

  public suspend fun proxyOtpLogin(input: ProxyTOtpLoginBody): ProxyTOtpLoginResponse {
    val url = "$authProxyUrl/v1/otp_login"
    if (authProxyConfigId.isNullOrBlank()) throw TurnkeyHttpError.MissingAuthProxyConfigId()
    val bodyJson = json.encodeToString(ProxyTOtpLoginBody.serializer(), input)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header("X-Auth-Proxy-Config-ID", authProxyConfigId).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /v1/otp_login: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(ProxyTOtpLoginResponse.serializer(), text)
    }
  }

  public suspend fun proxyVerifyOtp(input: ProxyTVerifyOtpBody): ProxyTVerifyOtpResponse {
    val url = "$authProxyUrl/v1/otp_verify"
    if (authProxyConfigId.isNullOrBlank()) throw TurnkeyHttpError.MissingAuthProxyConfigId()
    val bodyJson = json.encodeToString(ProxyTVerifyOtpBody.serializer(), input)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header("X-Auth-Proxy-Config-ID", authProxyConfigId).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /v1/otp_verify: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(ProxyTVerifyOtpResponse.serializer(), text)
    }
  }

  public suspend fun proxySignup(input: ProxyTSignupBody): ProxyTSignupResponse {
    val url = "$authProxyUrl/v1/signup"
    if (authProxyConfigId.isNullOrBlank()) throw TurnkeyHttpError.MissingAuthProxyConfigId()
    val bodyJson = json.encodeToString(ProxyTSignupBody.serializer(), input)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header("X-Auth-Proxy-Config-ID", authProxyConfigId).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /v1/signup: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(ProxyTSignupResponse.serializer(), text)
    }
  }

  public suspend fun proxyGetWalletKitConfig(input: ProxyTGetWalletKitConfigBody): ProxyTGetWalletKitConfigResponse {
    val url = "$authProxyUrl/v1/wallet_kit_config"
    if (authProxyConfigId.isNullOrBlank()) throw TurnkeyHttpError.MissingAuthProxyConfigId()
    val bodyJson = json.encodeToString(ProxyTGetWalletKitConfigBody.serializer(), input)
    val req = Request.Builder().url(url).post(bodyJson.toRequestBody("application/json".toMediaType())).header("X-Auth-Proxy-Config-ID", authProxyConfigId).header("X-Client-Version", Version.VERSION).build()
    val call = http.newCall(req)
    val resp = call.await()
    resp.use {
      if (!it.isSuccessful) {
        val errBody = withContext(Dispatchers.IO) { kotlin.runCatching { it.body.string() }.getOrNull() }
        throw RuntimeException("""HTTP error from /v1/wallet_kit_config: """ + it.code)
      }
      val text = withContext(Dispatchers.IO) { it.body.string() }
      return json.decodeFromString(ProxyTGetWalletKitConfigResponse.serializer(), text)
    }
  }

  public companion object {
    private val TERMINAL_ACTIVITY_STATUSES: Set<V1ActivityStatus> =
        setOf(V1ActivityStatus.ACTIVITY_STATUS_COMPLETED, V1ActivityStatus.ACTIVITY_STATUS_FAILED, V1ActivityStatus.ACTIVITY_STATUS_REJECTED)
  }
}
