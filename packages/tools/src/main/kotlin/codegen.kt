import com.squareup.kotlinpoet.*
import generators.generateApiTypes
import generators.generateClientFile
import generators.generateDefinitionsFromComponents
import io.swagger.v3.oas.models.OpenAPI
import io.swagger.v3.oas.models.media.Schema
import io.swagger.v3.parser.core.models.ParseOptions
import io.swagger.v3.parser.converter.SwaggerConverter
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.JsonObject
import java.nio.file.Files
import java.nio.file.Path
import kotlin.io.path.createDirectories
import utils.*

object VersionedActivityTypes {
    val map: Map<String, String> = mapOf(
        "ACTIVITY_TYPE_CREATE_AUTHENTICATORS" to "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2",
        "ACTIVITY_TYPE_CREATE_API_KEYS" to "ACTIVITY_TYPE_CREATE_API_KEYS_V2",
        "ACTIVITY_TYPE_CREATE_POLICY" to "ACTIVITY_TYPE_CREATE_POLICY_V3",
        "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS" to "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2",
        "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION" to "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7",
        "ACTIVITY_TYPE_CREATE_USERS" to "ACTIVITY_TYPE_CREATE_USERS_V3",
        "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD" to "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2",
        "ACTIVITY_TYPE_SIGN_TRANSACTION" to "ACTIVITY_TYPE_SIGN_TRANSACTION_V2",
        "ACTIVITY_TYPE_EMAIL_AUTH" to "ACTIVITY_TYPE_EMAIL_AUTH_V2",
        "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION" to "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2",
        "ACTIVITY_TYPE_UPDATE_POLICY" to "ACTIVITY_TYPE_UPDATE_POLICY_V2",
        "ACTIVITY_TYPE_INIT_OTP_AUTH" to "ACTIVITY_TYPE_INIT_OTP_AUTH_V2",
    )

    /** Fallbacks to the input if there’s no versioned entry. */
    fun resolve(type: String): String = map[type] ?: type
}

private fun Schema<*>.refName(): String? = this.`$ref`?.substringAfterLast("/")

/** Entry */
fun main(args: Array<String>) {
    val argv = args.toList()
    fun arg(name: String, default: String? = null): String =
        argv.getOrNull(argv.indexOf(name) + 1) ?: default
        ?: error("Missing $name")

    // ---- Collect repeated --spec <file> [--prefix <Prefix>] pairs
    val specs = mutableListOf<SpecCfg>()
    run {
        var i = 0
        while (i < argv.size) {
            if (argv[i] == "--spec") {
                val p = argv.getOrNull(i + 1) ?: error("Missing value after --spec")
                var prefix = ""
                if (i + 2 < argv.size && argv[i + 2] == "--prefix") {
                    prefix = argv.getOrNull(i + 3) ?: ""
                    i += 2
                }
                specs += SpecCfg(Path.of(p), prefix)
                i += 2
            } else i++
        }
    }
    require(specs.isNotEmpty()) { "At least one --spec is required (use: --spec path [--prefix Prefix])" }

    val outRoot = Path.of(arg("--out"))
    val pkg = arg("--pkg")
    val modelPkg = arg("--modelPkg")
    val clientClass = arg("--class", "TurnkeyClient")
    val typesPkg = arg("--typesPkg", pkg)
    val clientVersionHdr = arg("--clientVersion", "kotlin-sdk/0.1.0")

    specs.forEach { require(Files.exists(it.path)) { "Spec not found: ${it.path}" } }
    outRoot.createDirectories()

    // Parse all specs → OpenAPI 3
    val apis: List<Pair<SpecCfg, OpenAPI>> = specs.map { it to parseToOpenApi3(it.path) }
    val swaggerSpecs: List<Pair<SpecCfg, JsonObject>> = specs.map { it to readJson(it.path) }

    val fileBuilder = FileSpec.builder(pkg, "Models")
        .addFileComment("/* @generated by codegen. DO NOT EDIT BY HAND */")
        .addImport("kotlinx.serialization", "Serializable", "SerialName")
        .addImport("kotlinx.serialization.json", "JsonElement")

    generateDefinitionsFromComponents(swaggerSpecs, fileBuilder, pkg)
    generateApiTypes(swaggerSpecs, fileBuilder, pkg)
    fileBuilder.addAnnotation(
        AnnotationSpec.builder(Suppress::class)
            .useSiteTarget(AnnotationSpec.UseSiteTarget.FILE) // -> @file:Suppress(...)
            .addMember("%S", "unused")
            .addMember("%S", "UNUSED_PARAMETER")
            .addMember("%S", "UNUSED_VARIABLE")
            .addMember("%S", "RedundantVisibilityModifier")
            .addMember("%S", "MemberVisibilityCanBePrivate")
            .addMember("%S", "RedundantSuspendModifier")
            .build()
    ).build().writeTo(outRoot.toFile())
    generateClientFile(apis, outRoot, pkg, typesPkg, clientClass, clientVersionHdr)
}

private val JsonLoose = Json {
    ignoreUnknownKeys = false
    isLenient = true
    allowSpecialFloatingPointValues = true
}

fun readJson(path: Path): JsonObject {
    val raw = Files.readString(path)
    val el = try {
        JsonLoose.parseToJsonElement(raw)
    } catch (e: Exception) {
        error("Failed to parse JSON at $path: ${e.message}")
    }
    return el.jsonObjectOrFail("Top-level JSON must be an object at $path")
}

private fun JsonElement.jsonObjectOrFail(msg: String): JsonObject =
    this as? JsonObject ?: error(msg)

/** Convert Swagger 2.0 to OpenAPI 3 for easier traversal. */
private fun parseToOpenApi3(spec: Path): OpenAPI {
    val opts = ParseOptions().apply { isResolve = true; isFlatten = true }
    return SwaggerConverter().readLocation(spec.toString(), null, opts).openAPI
        ?: error("Failed to parse/convert spec: $spec")
}
